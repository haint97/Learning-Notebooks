//@version=5
indicator("MacroAcademic - VN Economy Engine", overlay=false, max_labels_count=500, max_lines_count=500, max_bars_back=5000, precision=4)

panelOption = input.string(defval = "Inflation", title = "Panel Ä‘ang xem", options = ["Inflation", "Rates & Liquidity", "GDP Growth", "Yield Curve Analysis", "RiskScore & Forecast", "Credit Growth", "Valuation & Divergence", "Policy Pressure", "Market & Sector","US Yield Curve" ])
panel = switch panelOption
    "Inflation" => 1
    "Rates & Liquidity" => 2
    "GDP Growth" => 3
    "Yield Curve Analysis" => 4
    "RiskScore & Forecast" => 5
    "Credit Growth" => 6
    "Valuation & Divergence" => 7
    "Policy Pressure" => 8
    "Market & Sector" => 9
    "US Yield Curve" => 10
    => 1
robustMode = input.string("Shock-sensitive", "Robust mode", options=["Shock-sensitive","Fully-robust MAD"])
threshold_mode = input.string("Static", "Che do nguong", options = ["Static", "Dynamic (z-score)", "Percentile-based"])
useYieldCurve = input.bool(true, "Bat Yield curve")
useCredit = input.bool(true, "Bat Credit")
useDXY = input.bool(true, "Bat DXY")
useValuation = input.bool(true, "Bat Valuation")
sym_infl="ECONOMICS:VNIRYY",sym_pol="ECONOMICS:VNINTR",sym_ib="ECONOMICS:VNINBR",sym_gdp="ECONOMICS:VNGDPYY",sym_m2="ECONOMICS:VNM2",sym_ppi="ECONOMICS:VNPPI",sym_fx="FX_IDC:USDVND",sym_dxy="TVC:DXY",sym_vn10y="TVC:VN10Y",sym_vn02y="TVC:VN02Y",sym_vn05y="TVC:VN05Y",sym_us10y="US10Y",sym_us02y="US02Y",sym_fed="USINTR",sym_vnindex="VNINDEX",sym_vn30="HOSE:VN30",sym_vn100="HOSE:VN100",sym_vnmidcap="HOSE:VNMIDCAP",sym_vnsmallcap="HOSE:VNSMALLCAP",sym_vnfin="HOSE:VNFIN",sym_vnreal="HOSE:VNREAL",sym_vncons="HOSE:VNCONS",sym_vnind="HOSE:VNIND"

infl_trend_len_m = input.int(24, "Trend lam phat (thang)", minval=6, maxval=120)
infl_z_len_m     = input.int(60, "Lookback (thang)", minval=24, maxval=240)
infl_clip        = input.float(2.5, "Clip (infl)", minval=1.5, maxval=6.0, step=0.1)

ewma_lambda      = input.float(0.30, "EWMA lambda", minval=0.05, maxval=0.95, step=0.01)
ar1_len_m        = input.int(60, "AR1 lookback (thang)", minval=24, maxval=240)
w_trend          = input.float(0.40, "Trong so Trend", minval=0.0, maxval=1.0, step=0.05)
w_ewma           = input.float(0.30, "Trong so EWMA",  minval=0.0, maxval=1.0, step=0.05)
w_ar1            = input.float(0.30, "Trong so AR1",   minval=0.0, maxval=1.0, step=0.05)

rreal_ema_len_m  = input.int(12, "EMA lai thuc (thang)", minval=3, maxval=60)
rate_z_len_m     = input.int(60, "Lookback (rate)", minval=24, maxval=240)
rate_clip        = input.float(2.5, "Clip (rate)", minval=1.5, maxval=6.0, step=0.1)

gdp_trend_len_q  = input.int(12, "Trend GDP (quy)", minval=4, maxval=40)
gdp_z_len_q      = input.int(40, "Lookback GDP (quy)", minval=16, maxval=120)
gdp_clip         = input.float(2.5, "Clip (GDP)", minval=1.5, maxval=6.0, step=0.1)

credit_trend_len_m = input.int(24, "Trend Credit (thang)", minval=6, maxval=120)
credit_z_len_m     = input.int(60, "Lookback Credit (thang)", minval=24, maxval=240)

drv_z_len_m      = input.int(60, "Lookback drivers", minval=24, maxval=240)
drv_clip         = input.float(2.5, "Clip (drivers)", minval=1.5, maxval=6.0, step=0.1)
ppi_trend_len_q  = input.int(12, "Trend PPI (quy)", minval=4, maxval=40)
ppi_z_len_q      = input.int(40, "Lookback PPI (quy)", minval=16, maxval=120)

pi_target        = input.float(4.0, "Muc tieu lam phat (%)", minval=0.0, maxval=15.0, step=0.1)
r_star           = input.float(1.0, "r* (%)", minval=-5.0, maxval=10.0, step=0.1)
phi_pi           = input.float(0.5, "He so lam phat", minval=0.0, maxval=2.0, step=0.05)
phi_y            = input.float(0.5, "He so GDP gap", minval=0.0, maxval=2.0, step=0.05)
policy_z_len_m   = input.int(60, "Lookback policy gap", minval=24, maxval=240)

w_stress=input.float(2.5,"Stress",minval=0,maxval=5,step=0.1)
w_curve=input.float(2.0,"YC",minval=0,maxval=5,step=0.1)
w_growth=input.float(1.5,"Growth",minval=0,maxval=5,step=0.1)
w_inflation=input.float(1.5,"Infl",minval=0,maxval=5,step=0.1)
w_intl=input.float(1.5,"Intl",minval=0,maxval=5,step=0.1)
w_spread=input.float(1.5,"Spread",minval=0,maxval=5,step=0.1)
w_credit=input.float(1.0,"Credit",minval=0,maxval=5,step=0.1)
w_dxy=input.float(1.0,"DXY",minval=0,maxval=5,step=0.1)
w_drv=input.float(1.0,"Drivers",minval=0,maxval=5,step=0.1)

percentile_lookback    = input.int(504, "Chu ky phan phoi (bars)", minval=100, maxval=2000)
clip_multiplier        = input.float(3.0, "Clip outliers (std)", minval=1.5, maxval=4.0, step=0.1)
risk_forecast_lookback = input.int(252, "Risk forecast lookback")


valuation_discount  = input.float(0.80, "Valuation Discount Threshold", minval=0.5, maxval=1.0, step=0.05, tooltip="GiÃ¡ < MA200 * threshold = ráº»")
divergence_lookback = input.int(60, "Divergence Lookback", minval=20, maxval=200)
dxy_threshold = input.float(105.0, "DXY Alert Threshold", minval=90, maxval=120, step=0.5)

w_fp = input.float(0.35, "Trong so Funding pressure", minval=0.0, maxval=1.0, step=0.05)
w_cp = input.float(0.25, "Trong so Curve pressure", minval=0.0, maxval=1.0, step=0.05)
w_ep = input.float(0.20, "Trong so External pressure", minval=0.0, maxval=1.0, step=0.05)
w_fx_pressure = input.float(0.20, "Trong so FX pressure", minval=0.0, maxval=1.0, step=0.05)
fx_shock_mult = input.float(1.2, "FX shock multiplier", minval=0.5, maxval=2.0, step=0.05)
norm_mode = input.string("Percentile", "Normalization mode", options=["Percentile", "Robust Z-score", "Hybrid"])
external_weight_mode = input.string("Fixed", "External weight mode", options=["Fixed", "Fed-sensitive"])
zone_low_pct = input.int(30, "Nguong zone thap (%)", minval=1, maxval=49)
zone_high_pct = input.int(70, "Nguong zone cao (%)", minval=51, maxval=99)

use_regime_mapping = input.bool(true, "Bat Regime Mapping")
regime_return_horizon = input.int(20, "Return horizon (bars)", minval=5, maxval=60)
use_log_return = input.bool(false, "Use log returns")
ret_clip_up = input.float(0.50, "Clip upper return", minval=0.1, maxval=2.0, step=0.05)
ret_clip_down = input.float(-0.30, "Clip lower return", minval=-0.99, maxval=0.0, step=0.05)
min_N_display = input.int(20, "Min N de hien thi", minval=5, maxval=100)
show_full_transition_matrix = input.bool(true, "Show Full 5x5 Transition Matrix", tooltip="Display detailed 5x5 matrix instead of simplified 3x3")

use_yc_lab = input.bool(true, "Bat Yield Curve Lab")
yc_stats_len = input.int(120, "YC stats window (days)", minval=30, maxval=500)
yc_clip_mult = input.float(2.5, "YC robust clip", minval=1.0, maxval=5.0, step=0.1)
yc_quality_threshold = input.float(50.0, "YC quality threshold", minval=0, maxval=100, step=5.0, tooltip="Quality < threshold = LOWQ")
use_yc_research = input.bool(true, "YC Research vs VNINDEX")
yc_research_len = input.int(120, "YC research window", minval=30, maxval=250)
yc_lag1 = input.int(1, "YC Research Lag #1", minval=0, maxval=60)
yc_lag2 = input.int(5, "YC Research Lag #2", minval=0, maxval=120)
yc_lag3 = input.int(20, "YC Research Lag #3", minval=0, maxval=252)
yc_min_eff_ratio = input.float(0.70, "YC min effective sample ratio", minval=0.30, maxval=1.00)
yc_ret_clip_mult = input.float(3.0, "YC VNINDEX return clip (stdev)", minval=1.0, maxval=8.0)
yc_lag_stab_len = input.int(60, "YC BestLag stability window", minval=20, maxval=252)

f_round(float x, int d) =>
    float m = math.pow(10.0, d)
    math.round(x * m) / m

f_fmt(float x, int d) =>
    string s = "-"
    if not na(x)
        s := str.tostring(f_round(x, d))
    s

f_fmt_pctl(float x) =>
    na(x) ? "-" : str.tostring(int(math.round(x)))



f_setLabel(label _lbl, int _x, float _y, string _txt, color _col) =>
    label L = _lbl
    if na(L)
        L := label.new(_x, _y, _txt)
        label.set_style(L, label.style_label_left)
        label.set_textcolor(L, color.white)
        label.set_color(L, color.new(_col, 0))
        label.set_size(L, size.normal)
    L

f_sec(string sym, string tf, float expr) =>
    request.security(sym, tf, expr, barmerge.gaps_off, barmerge.lookahead_off)

f_rollsum(float src, int length) =>
    float s = 0.0
    for i = 0 to length - 1
        s += nz(src[i])
    s


f_winsor_z(float src, int length, float clip_mult) =>
    float m  = ta.sma(src, length)
    float sd = ta.stdev(src, length)
    float hi = m + clip_mult * sd
    float lo = m - clip_mult * sd
    float clipped = src
    if not na(sd)
        clipped := math.max(lo, math.min(hi, src))
    float cm  = ta.sma(clipped, length)
    float csd = ta.stdev(clipped, length)
    float z = 0.0
    if csd > 0
        z := (src - cm) / csd
    z

f_mad_z(float src, int length) =>
    float med   = ta.percentile_nearest_rank(src, length, 50)
    float mad   = ta.percentile_nearest_rank(math.abs(src - med), length, 50)
    float denom = 1.4826 * mad
    float z = 0.0
    if denom > 0
        z := (src - med) / denom
    z

// Master z-score function that respects robustMode setting
// Used throughout the script for all z-score calculations
f_z(float src, int length, float clip_mult) =>
    robustMode == "Fully-robust MAD" ? f_mad_z(src, length) : f_winsor_z(src, length, clip_mult)


f_percentile_threshold(float src, int length, float percentile_val) =>
    ta.percentile_linear_interpolation(src, length, percentile_val)

f_check_percentile_warning(float src, int length, float percentile_val, bool is_low_bad) =>
    float thresh = f_percentile_threshold(src, length, percentile_val)
    is_low_bad ? src <= thresh : src >= thresh

f_bucket_from_risk(float risk) =>
    int b = na
    if not na(risk)
        b := risk < 20 ? 0 : risk < 40 ? 1 : risk < 60 ? 2 : risk < 80 ? 3 : 4
    b

f_bucket_label(int b) =>
    b == 0 ? "B0 (0â€“20)" : b == 1 ? "B1 (20â€“40)" : b == 2 ? "B2 (40â€“60)" : b == 3 ? "B3 (60â€“80)" : b == 4 ? "B4 (80â€“100)" : "NA"

f_bucket_bg(int bucket) =>
    bg = bucket == 4 ? color.new(color.red, 60) : bucket == 3 ? color.new(color.orange, 65) : bucket == 2 ? color.new(color.black, 85) : bucket == 1 ? color.new(color.green, 82) : color.new(color.green, 68)
    bg

f_risk_text(int bucket) =>
    bucket == 4 ? "Rui ro rat cao" : bucket == 3 ? "Rui ro cao" : bucket == 2 ? "Rui ro vua" : bucket == 1 ? "Rui ro thap" : "Rui ro rat thap"

f_pctl_text(float p, bool ranked) =>
    ranked ? f_fmt_pctl(p) : "NA"

f_clip_ret(float r) =>
    na(r) ? na : math.max(ret_clip_down, math.min(ret_clip_up, r))

f_compute_return(float c, float c_L) =>
    if not na(c) and not na(c_L) and c_L > 0
        float r_raw = use_log_return ? math.log(c / c_L) : (c - c_L) / c_L
        f_clip_ret(r_raw)
    else
        na

f_update_return_stats(float[] sumArr, float[] cntArr, float[] winArr, int idx, float ret) =>
    if not na(ret) and idx >= 0 and idx < array.size(sumArr)
        array.set(sumArr, idx, array.get(sumArr, idx) + ret)
        array.set(cntArr, idx, array.get(cntArr, idx) + 1.0)
        if ret > 0
            array.set(winArr, idx, array.get(winArr, idx) + 1.0)

f_avg(float sum, float cnt) =>
    cnt > 0 ? sum / cnt : na

f_winrate(float win, float cnt) =>
    cnt > 0 ? win / cnt * 100.0 : na

// Calculate maximum drawdown from price series
f_max_drawdown(float[] prices) =>
    float max_dd = 0.0
    int n = array.size(prices)
    if n > 1
        float peak = array.get(prices, 0)
        for i = 1 to n - 1
            float current = array.get(prices, i)
            if not na(current)
                if current > peak
                    peak := current
                else if peak > 0
                    float dd = (peak - current) / peak
                    if dd > max_dd
                        max_dd := dd
    max_dd

// Update drawdown stats
f_update_dd_stats(float[] maxArr, float[] sumArr, float[] cntArr, int idx, float dd) =>
    if not na(dd) and idx >= 0 and idx < array.size(maxArr)
        float current_max = array.get(maxArr, idx)
        if dd > current_max
            array.set(maxArr, idx, dd)
        array.set(sumArr, idx, array.get(sumArr, idx) + dd)
        array.set(cntArr, idx, array.get(cntArr, idx) + 1.0)

f_cov(float x, float y, int len) =>
    float mx=ta.sma(x,len),my=ta.sma(y,len),s=0.0
    for i=0 to len-1
        s+=nz((x[i]-mx)*(y[i]-my))
    s/len

f_var(float x,int len)=>
    float m=ta.sma(x,len),s=0.0
    for i=0 to len-1
        s+=nz((x[i]-m)*(x[i]-m))
    s/len

// YIELD CURVE HELPER FUNCTIONS
f_yc_regime_interp(string regime, string level_regime, string policy_stance) =>
    string result = ""
    if regime == "INVERTED" and level_regime == "HIGH RATE"
        result := "ðŸ”´ Inverted + High Rates â†’ Recession risk cao"
    else if regime == "INVERTED"
        result := "âš  Curve inverted â†’ Theo dÃµi recession signals"
    else if regime == "STEEP" and level_regime == "LOW RATE"
        result := "ðŸŸ¢ Steep + Low Rates â†’ Recovery phase"
    else if regime == "STEEP"
        result := "ðŸŸ¡ Steep curve â†’ Expansion phase"
    else if level_regime == "HIGH RATE"
        result := "âš  High rates + Flat â†’ Tightening peak?"
    else
        result := "âž¡ Neutral â†’ Theo dÃµi policy"
    result

f_yc_trading_view(string regime, string level_regime, string policy_stance) =>
    string result = ""
    if regime == "INVERTED"
        result := "ðŸ”´ Defensive: Giáº£m risk assets, tÄƒng bonds/cash/gold"
    else if regime == "STEEP" and policy_stance == "ACCOMMODATIVE"
        result := "ðŸŸ¢ Risk-on: TÄƒng stocks, giáº£m bonds"
    else if level_regime == "HIGH RATE"
        result := "âš  Selective: Æ¯u tiÃªn value stocks, short duration bonds"
    else
        result := "ðŸŸ¡ Balanced: Duy trÃ¬ portfolio cÃ¢n báº±ng"
    result

f_yc_timing(float slope_z) =>
    string result = ""
    if not na(slope_z) and slope_z < -2
        result := "Curve quÃ¡ flat â†’ Gáº§n Ä‘iá»ƒm Ä‘áº£o chiá»u?"
    else if not na(slope_z) and slope_z > 2
        result := "Curve quÃ¡ steep â†’ CÃ³ thá»ƒ flatten?"
    else
        result := "âž¡ Timing neutral â†’ Theo dÃµi policy meeting"
    result


var table t = table.new(position.top_right, 4, 75, border_width=1)

f_cell(int r, int c, string txt, color bg, color tc, halign) =>
    table.cell(t, c, r, txt, bgcolor=bg, text_color=tc, text_size=size.normal , text_halign=halign, text_valign=text.align_center)

f_hdr(int r, string txt) =>
    f_cell(r, 0, txt, color.new(color.blue, 15), color.white, text.align_left)
    table.merge_cells(t, 0, r, 3, r)
f_pctl_bg_dir(float p, bool highIsBad) =>
    color bg = color.new(color.black, 85)
    if not na(p)
        bool hi = p >= 80
        bool midhi = p >= 60 and p < 80
        bool midlo = p >= 40 and p < 60
        bool lo = p >= 20 and p < 40
        if highIsBad
            bg := hi ? color.new(color.red, 65) : midhi ? color.new(color.orange, 70) : midlo ? color.new(color.black, 85) : lo ? color.new(color.green, 82) : color.new(color.green, 68)
        else
            bg := hi ? color.new(color.green, 68) :  midhi ? color.new(color.green, 82) :  midlo ? color.new(color.black, 85) : lo ? color.new(color.orange, 70) : color.new(color.red, 65)
    bg
f_row(int r, string metric, string value, string pctl, float p, bool highbad, string meaning) =>
    color bg = color.black
    color p_bg = f_pctl_bg_dir(p, highbad)
    f_cell(r, 0, metric, bg, color.white, text.align_left)
    f_cell(r, 1, value,  bg, color.white, text.align_right)
    f_cell(r, 2, pctl,   p_bg, color.black, text.align_center)
    f_cell(r, 3, meaning,bg, color.white, text.align_left)
f_yc_display_lsc(table t, int row_offset, float level, float slope, float curve, float level_change, float slope_ma, float slope_z) =>
    int r = row_offset
    f_cell(r, 0, "LSC FACTORS", color.new(color.navy,50), color.white, text.align_center)
    table.merge_cells(t, 0, r, 3, r)
    r += 1

    f_cell(r, 0, "Level", color.new(color.blue,80), color.white, text.align_left)
    f_cell(r, 1, not na(level) ? f_fmt(level,2)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
    f_cell(r, 2, "Î” Level", color.new(color.blue,80), color.white, text.align_left)
    color level_chg_color = not na(level_change) and level_change > 0 ? color.new(color.red,50) : not na(level_change) and level_change < 0 ? color.new(color.green,50) : color.new(color.black,10)
    f_cell(r, 3, not na(level_change) ? (level_change > 0 ? "+" : "") + f_fmt(level_change,3)+"%" : "NA", level_chg_color, color.white, text.align_center)
    r += 1

    f_cell(r, 0, "Slope", color.new(color.blue,80), color.white, text.align_left)
    f_cell(r, 1, not na(slope) ? f_fmt(slope,2)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
    f_cell(r, 2, "Slope Z-Score", color.new(color.blue,80), color.white, text.align_left)
    color slope_z_color = not na(slope_z) and math.abs(slope_z) > 2 ? color.new(color.red,50) : color.new(color.black,10)
    f_cell(r, 3, not na(slope_z) ? f_fmt(slope_z,2) : "NA", slope_z_color, color.white, text.align_center)
    r += 1

    f_cell(r, 0, "Curvature", color.new(color.blue,80), color.white, text.align_left)
    f_cell(r, 1, not na(curve) ? f_fmt(curve,2)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
    f_cell(r, 2, "Slope MA(60)", color.new(color.blue,80), color.white, text.align_left)
    f_cell(r, 3, not na(slope_ma) ? f_fmt(slope_ma,2)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
    r + 1

f_yc_display_regime(table t, int row_offset, string regime, string level_regime, string policy_stance) =>
    int r = row_offset
    f_cell(r, 0, "REGIME ANALYSIS", color.new(color.navy,50), color.white, text.align_center)
    table.merge_cells(t, 0, r, 3, r)
    r += 1

    f_cell(r, 0, "Curve Shape", color.new(color.purple,80), color.white, text.align_left)
    color regime_color = regime == "INVERTED" ? color.new(color.red,50) : regime == "STEEP" ? color.new(color.green,50) : color.new(color.orange,50)
    string regime_icon = regime == "INVERTED" ? "ðŸ”´" : regime == "STEEP" ? "ðŸŸ¢" : "ðŸŸ¡"
    f_cell(r, 1, regime_icon + " " + regime, regime_color, color.white, text.align_center)
    table.merge_cells(t, 1, r, 3, r)
    r += 1

    f_cell(r, 0, "Rate Level", color.new(color.purple,80), color.white, text.align_left)
    color level_regime_color = level_regime == "HIGH RATE" ? color.new(color.red,50) : level_regime == "LOW RATE" ? color.new(color.green,50) : color.new(color.gray,50)
    f_cell(r, 1, level_regime, level_regime_color, color.white, text.align_center)
    table.merge_cells(t, 1, r, 3, r)
    r += 1

    f_cell(r, 0, "Policy Stance", color.new(color.purple,80), color.white, text.align_left)
    color policy_color = policy_stance == "RESTRICTIVE" ? color.new(color.red,50) : policy_stance == "ACCOMMODATIVE" ? color.new(color.green,50) : color.new(color.gray,50)
    f_cell(r, 1, policy_stance, policy_color, color.white, text.align_center)
    table.merge_cells(t, 1, r, 3, r)
    r + 1

f_yc_display_quality(table t, int row_offset, float quality_score, float vol_10y, float vol_2y) =>
    int r = row_offset
    f_cell(r, 0, "QUALITY METRICS", color.new(color.navy,50), color.white, text.align_center)
    table.merge_cells(t, 0, r, 3, r)
    r += 1

    f_cell(r, 0, "Quality Score", color.new(color.blue,80), color.white, text.align_left)
    color qual_color = not na(quality_score) and quality_score >= 80 ? color.new(color.green,60) : not na(quality_score) and quality_score >= 50 ? color.new(color.orange,60) : color.new(color.red,60)
    string qual_label = not na(quality_score) and quality_score >= 80 ? "HIGH" : not na(quality_score) and quality_score >= 50 ? "MEDIUM" : "LOW"
    f_cell(r, 1, not na(quality_score) ? f_fmt(quality_score,1)+"% ("+qual_label+")" : "NA", qual_color, color.white, text.align_center)
    table.merge_cells(t, 1, r, 3, r)
    r += 1

    f_cell(r, 0, "10Y Vol (20d)", color.new(color.blue,80), color.white, text.align_left)
    f_cell(r, 1, not na(vol_10y) ? f_fmt(vol_10y,3)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
    f_cell(r, 2, "2Y Vol (20d)", color.new(color.blue,80), color.white, text.align_left)
    f_cell(r, 3, not na(vol_2y) ? f_fmt(vol_2y,3)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
    r + 1

f_vn_impact_from_us(float vn_us_spread, float fed_gap) =>
    string result = ""
    if not na(vn_us_spread) and vn_us_spread > 3.0
        result := "VN spread rá»™ng â†’ Háº¥p dáº«n cho foreign investors"
    else if not na(vn_us_spread) and vn_us_spread < 1.0
        result := "âš  VN spread háº¹p â†’ Capital outflow risk"
    else if not na(fed_gap) and fed_gap > 2.0
        result := "Fed rate cao hÆ¡n VN nhiá»u â†’ Äá»“ng USD máº¡nh, Ã¡p lá»±c lÃªn VND"
    else
        result := "âž¡ Spread á»•n Ä‘á»‹nh â†’ Impact trung tÃ­nh"
    result

f_yc_display_vn_lab(table t, int row_offset, float level, float slope, float curve, string regime_code, float quality, string quality_label, float distortion, float stress_raw, float stress_adj) =>
    int r = row_offset
    f_hdr(r, "YIELD CURVE LAB (L-S-C + Quality)")
    r += 1

    f_cell(r, 0, "Level", color.new(color.blue,20), color.white, text.align_left)
    f_cell(r, 1, not na(level) ? f_fmt(level,2)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
    f_cell(r, 2, "Slope", color.new(color.blue,20), color.white, text.align_left)
    f_cell(r, 3, not na(slope) ? f_fmt(slope,2)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
    r += 1

    f_cell(r, 0, "Curvature", color.new(color.blue,20), color.white, text.align_left)
    f_cell(r, 1, not na(curve) ? f_fmt(curve,2)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
    f_cell(r, 2, "Regime", color.new(color.blue,20), color.white, text.align_left)
    color regime_color = regime_code == "YC4" ? color.new(color.red,60) : regime_code == "YC1" ? color.new(color.green,60) : color.new(color.orange,60)
    f_cell(r, 3, regime_code, regime_color, color.white, text.align_center)
    r += 1

    r += 1
    f_hdr(r, "QUALITY & STRESS")
    r += 1

    f_cell(r, 0, "Quality", color.new(color.blue,20), color.white, text.align_left)
    color qual_color = quality_label == "HIGHQ" ? color.new(color.green,60) : quality_label == "LOWQ" ? color.new(color.red,60) : color.new(color.orange,60)
    f_cell(r, 1, not na(quality) ? f_fmt(quality,1)+"% ("+quality_label+")" : "NA", qual_color, color.white, text.align_center)
    table.merge_cells(t, 1, r, 3, r)
    r += 1

    f_cell(r, 0, "Distortion", color.new(color.blue,20), color.white, text.align_left)
    f_cell(r, 1, not na(distortion) ? f_fmt(distortion,3) : "NA", color.new(color.black,10), color.white, text.align_center)
    table.merge_cells(t, 1, r, 3, r)
    r += 1

    f_cell(r, 0, "Stress (raw)", color.new(color.blue,20), color.white, text.align_left)
    f_cell(r, 1, not na(stress_raw) ? f_fmt(stress_raw,1)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
    f_cell(r, 2, "Stress (adj)", color.new(color.blue,20), color.white, text.align_left)
    color stress_color = not na(stress_adj) and stress_adj >= 70 ? color.new(color.red,60) : not na(stress_adj) and stress_adj <= 40 ? color.new(color.green,60) : color.new(color.black,10)
    f_cell(r, 3, not na(stress_adj) ? f_fmt(stress_adj,1)+"%" : "NA", stress_color, color.white, text.align_center)
    r + 1




f_pi_trend(float src) => ta.ema(src, infl_trend_len_m)

f_pi_ewma(float src) =>
    var float ew = na
    if na(ew[1])
        ew := src
    else
        ew := ewma_lambda * src + (1.0 - ewma_lambda) * ew[1]
    ew

f_pi_ar1_expect(float src) =>
    float y    = src[1]
    float x    = src[2]
    float cov  = f_cov(y, x, ar1_len_m)
    float varx = f_var(x, ar1_len_m)
    float beta = varx > 0 ? cov / varx : 0.0
    float my = ta.sma(y, ar1_len_m)
    float mx = ta.sma(x, ar1_len_m)
    float a  = my - beta * mx
    a + beta * y

f_pi_ensemble_expect(float src) =>
    float tr = f_pi_trend(src)
    float ew = f_pi_ewma(src)
    float ar = f_pi_ar1_expect(src)
    float wsum = w_trend + w_ewma + w_ar1
    float wt = wsum > 0 ? w_trend / wsum : 1.0
    float we = wsum > 0 ? w_ewma  / wsum : 0.0
    float wa = wsum > 0 ? w_ar1   / wsum : 0.0
    wt * tr[1] + we * ew[1] + wa * ar

float pi_m       = f_sec(sym_infl, "M", close)
float pi_trend_m = f_sec(sym_infl, "M", f_pi_trend(close))
float dpi_m      = f_sec(sym_infl, "M", close - close[1])
float pi_e_m     = f_sec(sym_infl, "M", f_pi_ensemble_expect(close))
float surprise_m = f_sec(sym_infl, "M", close - f_pi_ensemble_expect(close))
float pi_gap_m   = pi_m - pi_trend_m

float m2_m = na
float m2_trend_m = na
float m2_gap_m = na
float m2_yoy_m = na
float credit_idx = na

if useCredit
    m2_m := f_sec(sym_m2, "M", close)
    m2_trend_m := f_sec(sym_m2, "M", ta.ema(close, credit_trend_len_m))
    m2_gap_m := m2_m - m2_trend_m
    m2_yoy_m := f_sec(sym_m2, "M", (close / close[12] - 1) * 100)
    credit_idx := f_z(m2_gap_m, credit_z_len_m, 2.5)


float dxy_m = na
float dxy_stress = na

if useDXY
    dxy_m := f_sec(sym_dxy, "M", close)
    dxy_stress := dxy_m > dxy_threshold ? 1.0 : 0.0

float i_policy_m = f_sec(sym_pol, "M", close)
float i_ib_m     = f_sec(sym_ib,  "M", close)
float di_ib_m    = f_sec(sym_ib,  "M", close - close[1])

float r_real_m   = i_policy_m - pi_e_m
bool  isNewMonth = timeframe.change("M")
float alpha_m    = 2.0 / (rreal_ema_len_m + 1.0)

var float rreal_ema_m = na
if isNewMonth
    rreal_ema_m := na(rreal_ema_m) ? r_real_m : alpha_m * r_real_m + (1.0 - alpha_m) * rreal_ema_m

float r_real_gap_m = r_real_m - rreal_ema_m
float tight_idx = f_z(r_real_gap_m, rate_z_len_m, rate_clip) + 0.5 * f_z(di_ib_m, rate_z_len_m, rate_clip)

float gdp_q       = f_sec(sym_gdp, "3M", close)
float gdp_trend_q = f_sec(sym_gdp, "3M", ta.ema(close, gdp_trend_len_q))
float gdp_gap_q   = gdp_q - gdp_trend_q
float grow_idx    = f_z(gdp_gap_q, gdp_z_len_q, gdp_clip)

float i_implied  = r_star + pi_m + phi_pi * (pi_m - pi_target) + phi_y * gdp_gap_q
float policy_gap = i_policy_m - i_implied



float us10y_m = f_sec(sym_us10y, "M", close)
float us02y_m = f_sec(sym_us02y, "M", close)
float us_yc_slope = us10y_m - us02y_m



vn10y_m = f_sec(sym_vn10y, "M", close)
vn02y_m = f_sec(sym_vn02y, "M", close)
yc_slope_m = math.min(vn10y_m - vn02y_m, us_yc_slope)
yc_idx = f_z(yc_slope_m, 60, 2.5)
intl_yield_diff = vn10y_m - us10y_m
long_short_spread = vn10y_m - i_policy_m
intl_idx = f_z(intl_yield_diff, 60, 2.5)
spread_idx = f_z(long_short_spread, 60, 2.5)




// YC Lab factors
float yc_level = na
float yc_slope = na
float yc_curve = na
float yc_quality = na
float yc_distortion = na
float yc_stress_raw = na
float yc_stress_adj = na
string yc_regime_code = "YC0"
string yc_quality_label = "NA"
float vn02y_d = na
float vn05y_d = na
float vn10y_d = na
if use_yc_lab
    vn02y_d :=  f_sec(sym_vn02y, "D", close)
    vn05y_d := f_sec(sym_vn05y, "D", close)
    vn10y_d := f_sec(sym_vn10y, "D", close)
    yc_level := (vn02y_d + vn05y_d + vn10y_d) / 3.0
    yc_slope := vn10y_d - vn02y_d
    yc_curve := 2.0 * vn05y_d - vn02y_d - vn10y_d

    // Robust z-scores for each tenor (respects robustMode: Shock-sensitive or Fully-robust MAD)
    float y2_z = f_z(vn02y_d, yc_stats_len, yc_clip_mult)
    float y5_z = f_z(vn05y_d, yc_stats_len, yc_clip_mult)
    float y10_z = f_z(vn10y_d, yc_stats_len, yc_clip_mult)

    float mean_z = ( y2_z +  y5_z + y10_z) / 3.0
    float dz2 = y2_z - mean_z
    float dz5 = y5_z - mean_z
    float dz10 = y10_z - mean_z
    float var_z = ( dz2*dz2 +  dz5*dz5 +  dz10*dz10) / 6.0
    yc_distortion := math.sqrt(var_z)
    float dist_clamp = math.min(1.2, math.max(0.0, yc_distortion))

    yc_quality := 100.0 - (dist_clamp / 1.2) * 100.0
    yc_quality_label := yc_quality >= 75 ? "HIGHQ" : yc_quality >= yc_quality_threshold ? "MEDQ" : "LOWQ"

    float level_pct = ta.percentrank(yc_level, yc_stats_len)
    float slope_risk = yc_slope <= 0 ? 100.0 : (100.0 - ta.percentrank(yc_slope, yc_stats_len))
    yc_stress_raw := (level_pct + slope_risk) / 2.0
    yc_stress_adj := yc_stress_raw * (yc_quality / 100.0)

    string level_bucket = level_pct >= 70 ? "HIGH" : level_pct <= 30 ? "LOW" : "MID"
    bool slope_inverted = yc_slope <= 0
    bool slope_steep = yc_slope > ta.percentile_linear_interpolation(yc_slope, yc_stats_len, 70)

    if level_bucket == "HIGH" and (slope_inverted or not slope_steep)
        yc_regime_code := "YC4"  // Tight: high level + flat/inverted
    else if level_bucket == "HIGH" and slope_steep
        yc_regime_code := "YC3"  // Late tightening
    else if level_bucket == "LOW" and slope_steep
        yc_regime_code := "YC2"  // Early easing
    else if level_bucket == "LOW"
        yc_regime_code := "YC1"  // Easing mature
    else
        yc_regime_code := "YC0"  // Neutral

//Lag stability and regime filtering
var int[] yc_lag_hist=array.new_int()
float yc_vnx_corr_lag1=na
float yc_vnx_corr_lag2=na
float yc_vnx_corr_lag3=na
float yc_vnx_beta_best=na
float yc_vnx_r2_best=na
float yc_lag_stability=na
float yc_eff_n=na
int yc_best_lag=na
string yc_research_status="OFF"

// Regime-filtered research variables
float yc_vnx_corr_okq=na
float yc_vnx_beta_okq=na
float yc_eff_n_okq=na
string yc_okq_status="OFF"

if use_yc_research
    float vnx_d=f_sec(sym_vnindex,"D",close),vnx_ret=not na(vnx_d)and not na(vnx_d[1])and vnx_d[1]>0?math.log(vnx_d/vnx_d[1]):na
    float vnx_ret_clip=na
    if not na(vnx_ret)
        float rm=ta.sma(vnx_ret,yc_research_len),rs=ta.stdev(vnx_ret,yc_research_len)
        vnx_ret_clip:=math.max(rm-yc_ret_clip_mult*rs,math.min(rm+yc_ret_clip_mult*rs,vnx_ret))
    int vcnt=0
    for i=0 to yc_research_len-1
        if not na(yc_stress_adj[i])and not na(vnx_ret_clip[i])
            vcnt+=1
    yc_eff_n:=vcnt
    float er=vcnt/float(yc_research_len)
    yc_research_status:=er>=yc_min_eff_ratio?"READY":"LOW N"
    if yc_research_status=="READY"
        float c1=f_cov(yc_stress_adj,vnx_ret_clip[yc_lag1],yc_research_len),c2=f_cov(yc_stress_adj,vnx_ret_clip[yc_lag2],yc_research_len),c3=f_cov(yc_stress_adj,vnx_ret_clip[yc_lag3],yc_research_len)
        float vs=f_var(yc_stress_adj,yc_research_len),v1=f_var(vnx_ret_clip[yc_lag1],yc_research_len),v2=f_var(vnx_ret_clip[yc_lag2],yc_research_len),v3=f_var(vnx_ret_clip[yc_lag3],yc_research_len)
        yc_vnx_corr_lag1:=vs>0 and v1>0?c1/math.sqrt(vs*v1):na
        yc_vnx_corr_lag2:=vs>0 and v2>0?c2/math.sqrt(vs*v2):na
        yc_vnx_corr_lag3:=vs>0 and v3>0?c3/math.sqrt(vs*v3):na
        float a1=math.abs(yc_vnx_corr_lag1),a2=math.abs(yc_vnx_corr_lag2),a3=math.abs(yc_vnx_corr_lag3)
        if a1>=a2 and a1>=a3
            yc_best_lag:=yc_lag1
            yc_vnx_beta_best:=vs>0?c1/vs:na
            yc_vnx_r2_best:=yc_vnx_corr_lag1*yc_vnx_corr_lag1
        else if a2>=a3
            yc_best_lag:=yc_lag2
            yc_vnx_beta_best:=vs>0?c2/vs:na
            yc_vnx_r2_best:=yc_vnx_corr_lag2*yc_vnx_corr_lag2
        else
            yc_best_lag:=yc_lag3
            yc_vnx_beta_best:=vs>0?c3/vs:na
            yc_vnx_r2_best:=yc_vnx_corr_lag3*yc_vnx_corr_lag3

        // Track best lag for stability calculation
        array.push(yc_lag_hist, yc_best_lag)
        if array.size(yc_lag_hist) > yc_lag_stab_len
            array.shift(yc_lag_hist)

        // Calculate lag stability (% of time best lag is consistent)
        if array.size(yc_lag_hist) >= yc_lag_stab_len
            int stable_count = 0
            int mode_lag = yc_best_lag
            for i = 0 to array.size(yc_lag_hist) - 1
                if array.get(yc_lag_hist, i) == mode_lag
                    stable_count += 1
            yc_lag_stability := 100.0 * stable_count / array.size(yc_lag_hist)

        // Regime-filtered research (OKQ: Only OK Quality)
        if yc_quality_label != "LOWQ"
            int okq_cnt = 0
            float okq_sum_xy = 0.0
            float okq_sum_x = 0.0
            float okq_sum_y = 0.0
            float okq_sum_x2 = 0.0
            float okq_sum_y2 = 0.0

            for i = 0 to yc_research_len - 1
                // Check if quality was OK at that point
                float past_quality = yc_quality[i]
                bool was_okq = not na(past_quality) and past_quality >= yc_quality_threshold

                if was_okq and not na(yc_stress_adj[i]) and not na(vnx_ret_clip[i])
                    float x = yc_stress_adj[i]
                    float y = vnx_ret_clip[i]
                    okq_sum_xy += x * y
                    okq_sum_x += x
                    okq_sum_y += y
                    okq_sum_x2 += x * x
                    okq_sum_y2 += y * y
                    okq_cnt += 1

            yc_eff_n_okq := okq_cnt
            float okq_ratio = okq_cnt / float(yc_research_len)
            yc_okq_status := okq_ratio >= yc_min_eff_ratio ? "READY" : "LOW N"

            if yc_okq_status == "READY"
                float n = okq_cnt
                float cov_xy = (okq_sum_xy - okq_sum_x * okq_sum_y / n) / n
                float var_x = (okq_sum_x2 - okq_sum_x * okq_sum_x / n) / n
                float var_y = (okq_sum_y2 - okq_sum_y * okq_sum_y / n) / n

                yc_vnx_corr_okq := var_x > 0 and var_y > 0 ? cov_xy / math.sqrt(var_x * var_y) : na
                yc_vnx_beta_okq := var_x > 0 ? cov_xy / var_x : na



float us_level = (us02y_m + us10y_m) / 2.0
float us_curve = us02y_m - 2 * ((us02y_m + us10y_m) / 2.0) + us10y_m  // Approximation with 2 tenors

float us_slope_ma = ta.sma(us_yc_slope, 60)
float us_slope_std = ta.stdev(us_yc_slope, 60)
float us_slope_z = na(us_slope_std) or us_slope_std == 0 ? 0 : (us_yc_slope - us_slope_ma) / us_slope_std
float us_level_ma = ta.sma(us_level, 60)
float us_level_change = us_level - us_level[1]

float us_10y_vol = ta.stdev(us10y_m, 20)
float us_02y_vol = ta.stdev(us02y_m, 20)
float us_data_avail = (na(us10y_m) ? 0 : 1) + (na(us02y_m) ? 0 : 1)
float us_quality_score = us_data_avail >= 2 and not na(us_10y_vol) and not na(us_02y_vol) ? 90.0 : us_data_avail >= 1 ? 50.0 : 0.0

// US YC REGIME CLASSIFICATION
string us_regime = us_yc_slope > 0.5 ? "STEEP" : us_yc_slope < -0.2 ? "INVERTED" : "FLAT"
string us_level_regime = us_level > us_level_ma + us_slope_std ? "HIGH RATE" : us_level < us_level_ma - us_slope_std ? "LOW RATE" : "NEUTRAL"

// FED POLICY RATE & GAP ANALYSIS
float fed_policy_rate_m = f_sec(sym_fed, "M", close)
float fed_gap = fed_policy_rate_m - i_policy_m  // Fed - VN gap
float us_policy_spread = us10y_m - fed_policy_rate_m  // 10Y vs Fed rate spread
string us_policy_stance = us_policy_spread > 1.0 ? "ACCOMMODATIVE" : us_policy_spread < 0 ? "RESTRICTIVE" : "NEUTRAL"

float fx_rate_d = f_sec(sym_fx, "D", close)
float fx_yoy_change = na(fx_rate_d) or na(fx_rate_d[252]) ? na : ((fx_rate_d - fx_rate_d[252]) / fx_rate_d[252]) * 100.0
float fx_return_21 = na(fx_rate_d) or na(fx_rate_d[21]) ? na : ((fx_rate_d - fx_rate_d[21]) / fx_rate_d[21]) * 100.0
float fx_vol_3m = ta.stdev(fx_return_21, 63)
float fx_yoy_abs = math.abs(fx_yoy_change)




// N) VALUATION CHECK

float vnindex_d = na
float vnindex_ma200 = na
float valuation_distance = na
bool is_cheap = false

if useValuation
    vnindex_d := f_sec(sym_vnindex, "D", close)
    vnindex_ma200 := f_sec(sym_vnindex, "D", ta.sma(close, 200))
    valuation_distance := vnindex_d / vnindex_ma200
    is_cheap := valuation_distance < valuation_discount


// O) DIVERGENCE DETECTION

float vnindex_m = f_sec(sym_vnindex, "M", close)
float vnindex_mom_m = math.log(vnindex_m / vnindex_m[1])

f_find_low(float src, int len) =>
    float low_val = src
    for i = 1 to len - 1
        if not na(src[i]) and src[i] < low_val
            low_val := src[i]
    low_val

f_find_high(float src, int len) =>
    float high_val = src
    for i = 1 to len - 1
        if not na(src[i]) and src[i] > high_val
            high_val := src[i]
    high_val

float price_low_current = vnindex_m
float price_low_prev = f_find_low(vnindex_m[1], divergence_lookback)
bool price_lower_low = price_low_current < price_low_prev


// P) MARKET & SECTOR INDICES DATA

float vn30_d = f_sec(sym_vn30, "D", close)
float vn100_d = na
float vnmidcap_d = na
float vnsmallcap_d = na


float vnfin_d = na
float vnreal_d = na
float vncons_d = na
float vnind_d = na

if use_regime_mapping
    vn100_d := f_sec(sym_vn100, "D", close)
    vnmidcap_d := f_sec(sym_vnmidcap, "D", close)
    vnsmallcap_d := f_sec(sym_vnsmallcap, "D", close)

    vnfin_d := f_sec(sym_vnfin, "D", close)
    vnreal_d := f_sec(sym_vnreal, "D", close)
    vncons_d := f_sec(sym_vncons, "D", close)
    vnind_d := f_sec(sym_vnind, "D", close)

var float[] sumR_market = array.new_float(25, 0.0)
var float[] cntR_market = array.new_float(25, 0.0)
var float[] winR_market = array.new_float(25, 0.0)

// Additional performance tracking: R20, R60, DD20, DD60
var float[] sumR20_market = array.new_float(25, 0.0)
var float[] cntR20_market = array.new_float(25, 0.0)
var float[] winR20_market = array.new_float(25, 0.0)
var float[] sumR60_market = array.new_float(25, 0.0)
var float[] cntR60_market = array.new_float(25, 0.0)
var float[] maxDD20_market = array.new_float(25, 0.0)
var float[] sumDD20_market = array.new_float(25, 0.0)
var float[] cntDD20_market = array.new_float(25, 0.0)
var float[] maxDD60_market = array.new_float(25, 0.0)

var float[] sumRR_sector = array.new_float(20, 0.0)
var float[] cntRR_sector = array.new_float(20, 0.0)
var float[] winRR_sector = array.new_float(20, 0.0)

// Sector performance tracking
var float[] sumRR20_sector = array.new_float(20, 0.0)
var float[] cntRR20_sector = array.new_float(20, 0.0)
var float[] winRR20_sector = array.new_float(20, 0.0)

var int[] transition_matrix = array.new_int(25, 0)
var int prev_bucket = na
var int current_bucket_duration = 0
var float[] bucket_durations = array.new_float(5, 0.0)
var int[] bucket_visit_count = array.new_int(5, 0)


// P) RISK SCORE + PARTS
float infl_gap_idx = f_z(pi_gap_m, infl_z_len_m, infl_clip)
float mom_idx      = f_z(dpi_m,    infl_z_len_m, infl_clip)
float sur_idx      = f_z(surprise_m, infl_z_len_m, infl_clip)

bool stress_high = false
if threshold_mode == "Dynamic (z-score)"
    stress_high := f_z(tight_idx, rate_z_len_m, clip_multiplier) > 1.0
else if threshold_mode == "Percentile-based"
    stress_high := f_check_percentile_warning(tight_idx, percentile_lookback, 85, false)
else
    stress_high := tight_idx > 1.5

if useDXY and dxy_stress > 0
    stress_high := true

bool curve_inversion = false
if useYieldCurve
    if threshold_mode == "Dynamic (z-score)"
        curve_inversion := f_z(yc_slope_m, 60, clip_multiplier) < -1.0
    else if threshold_mode == "Percentile-based"
        curve_inversion := yc_slope_m <= f_percentile_threshold(yc_slope_m, percentile_lookback, 15)
    else
        curve_inversion := yc_slope_m < 0

// Calculate z-scores for macro variables
float gdp_z = f_z(gdp_gap_q, gdp_z_len_q, clip_multiplier)
float infl_z = f_z(pi_m, infl_z_len_m, clip_multiplier)

bool inflation_high = false
if threshold_mode == "Dynamic (z-score)"
    inflation_high := infl_z > 1.0
else if threshold_mode == "Percentile-based"
    inflation_high := f_check_percentile_warning(pi_m, percentile_lookback, 85, false)
else
    inflation_high := pi_m > pi_target + 1.0


bool growth_low = false
if threshold_mode == "Dynamic (z-score)"
    growth_low := f_z(gdp_gap_q, gdp_z_len_q, clip_multiplier) < -1.0
else if threshold_mode == "Percentile-based"
    growth_low := f_check_percentile_warning(gdp_gap_q, percentile_lookback, 15, true)
else
    growth_low := gdp_gap_q < 0

bool drivers_high = false


// Credit warning
bool credit_high = false
if useCredit
    if threshold_mode == "Dynamic (z-score)"
        credit_high := f_z(credit_idx, credit_z_len_m, clip_multiplier) > 1.0
    else if threshold_mode == "Percentile-based"
        credit_high := f_check_percentile_warning(credit_idx, percentile_lookback, 85, false)
    else
        credit_high := credit_idx > 1.0
bool external_stress = false


bool intl_warning = false
bool spread_warning = false
if useYieldCurve
    if threshold_mode == "Dynamic (z-score)"
        intl_warning := f_z(intl_yield_diff, 60, clip_multiplier) < -1.0
        spread_warning := f_z(long_short_spread, 60, clip_multiplier) < -1.0
    else if threshold_mode == "Percentile-based"
        intl_warning := f_check_percentile_warning(intl_yield_diff, percentile_lookback, 15, true)
        spread_warning := f_check_percentile_warning(long_short_spread, percentile_lookback, 15, true)
    else
        intl_warning := intl_yield_diff < 0.5
        spread_warning := long_short_spread < 0.5

// RECALIBRATED LAYERS
float layer1_score = stress_high ? w_stress : 0.0
layer1_score += useDXY and dxy_stress > 0 ? w_dxy : 0.0

float layer2_score = (curve_inversion ? w_curve : 0.0) + (growth_low ? w_growth : 0.0) + (spread_warning ? w_spread : 0.0)

float layer3_score = (intl_warning ? w_intl : 0.0) + (inflation_high ? w_inflation : 0.0) + (drivers_high ? w_drv : 0.0) + (external_stress ? 1.0 : 0.0)
layer3_score += useCredit and credit_high ? w_credit : 0.0

float risk_score = layer1_score + layer2_score + layer3_score
float max_score = w_stress + w_curve + w_growth + w_spread + w_intl + w_inflation + w_drv + w_credit + w_dxy + 1.0
float risk_pct = max_score > 0 ? (risk_score / max_score) * 100.0 : 0.0

// VALUATION ADJUSTMENT
if useValuation and is_cheap and risk_pct > 60
    risk_pct := risk_pct * 0.85  // Giáº£m 15% náº¿u giÃ¡ ráº»

float risk_forecast = ta.linreg(risk_pct, risk_forecast_lookback, 0)
int risk_bucket = f_bucket_from_risk(risk_pct)
int current_bucket = risk_bucket

if not na(prev_bucket) and not na(risk_bucket)
    if prev_bucket == risk_bucket
        current_bucket_duration += 1
    else
        int from_idx = prev_bucket
        int to_idx = risk_bucket
        int matrix_idx = from_idx * 5 + to_idx
        int current_count = array.get(transition_matrix, matrix_idx)
        array.set(transition_matrix, matrix_idx, current_count + 1)
        if current_bucket_duration > 0
            float prev_avg = array.get(bucket_durations, prev_bucket)
            int prev_visits = array.get(bucket_visit_count, prev_bucket)
            float new_avg = prev_visits > 0 ? (prev_avg * prev_visits + current_bucket_duration) / (prev_visits + 1) : current_bucket_duration
            array.set(bucket_durations, prev_bucket, new_avg)
            array.set(bucket_visit_count, prev_bucket, prev_visits + 1)

        // Reset duration counter
        current_bucket_duration := 1
        prev_bucket := risk_bucket
else if not na(risk_bucket)
    prev_bucket := risk_bucket
    current_bucket_duration := 1

// MACRO REVERSAL DETECTION
bool macro_improving = risk_forecast < risk_pct and risk_pct < 60
bool macro_deteriorating = risk_forecast > risk_pct and risk_pct > 40

// DIVERGENCE SIGNAL
float risk_high_current = risk_pct
float risk_high_prev = f_find_high(risk_pct[1], divergence_lookback)
bool risk_lower_high = risk_high_current < risk_high_prev

bool bullish_divergence = price_lower_low and risk_lower_high and risk_pct < 70

// Risk component scores (binary: 0 or 1)
float S_infl = inflation_high ? 1.0 : 0.0
float S_pol  = stress_high     ? 1.0 : 0.0
float S_grow = growth_low      ? 1.0 : 0.0
float S_drv  = drivers_high    ? 1.0 : 0.0


var float[] vnindex_hist = array.new_float(0)
var float[] vn30_hist = array.new_float(0)
var float[] vn100_hist = array.new_float(0)
var float[] vnmidcap_hist = array.new_float(0)
var float[] vnsmallcap_hist = array.new_float(0)
var float[] vnfin_hist = array.new_float(0)
var float[] vnreal_hist = array.new_float(0)
var float[] vncons_hist = array.new_float(0)
var float[] vnind_hist = array.new_float(0)
var int[] bucket_hist = array.new_int(0)

if use_regime_mapping
    array.push(vnindex_hist, vnindex_d)
    array.push(vn30_hist, vn30_d)
    array.push(vn100_hist, vn100_d)
    array.push(vnmidcap_hist, vnmidcap_d)
    array.push(vnsmallcap_hist, vnsmallcap_d)
    array.push(vnfin_hist, vnfin_d)
    array.push(vnreal_hist, vnreal_d)
    array.push(vncons_hist, vncons_d)
    array.push(vnind_hist, vnind_d)
    array.push(bucket_hist, risk_bucket)

    int max_hist = regime_return_horizon + 10
    if array.size(vnindex_hist) > max_hist
        array.shift(vnindex_hist)
        array.shift(vn30_hist)
        array.shift(vn100_hist)
        array.shift(vnmidcap_hist)
        array.shift(vnsmallcap_hist)
        array.shift(vnfin_hist)
        array.shift(vnreal_hist)
        array.shift(vncons_hist)
        array.shift(vnind_hist)
        array.shift(bucket_hist)

    int hist_size = array.size(vnindex_hist)
    if hist_size > regime_return_horizon
        int past_bucket = array.get(bucket_hist, hist_size - regime_return_horizon - 1)
        float vnindex_past = array.get(vnindex_hist, hist_size - regime_return_horizon - 1)
        float vnindex_now = array.get(vnindex_hist, hist_size - 1)
        float vn30_past = array.get(vn30_hist, hist_size - regime_return_horizon - 1)
        float vn30_now = array.get(vn30_hist, hist_size - 1)
        float vn100_past = array.get(vn100_hist, hist_size - regime_return_horizon - 1)
        float vn100_now = array.get(vn100_hist, hist_size - 1)
        float vnmidcap_past = array.get(vnmidcap_hist, hist_size - regime_return_horizon - 1)
        float vnmidcap_now = array.get(vnmidcap_hist, hist_size - 1)
        float vnsmallcap_past = array.get(vnsmallcap_hist, hist_size - regime_return_horizon - 1)
        float vnsmallcap_now = array.get(vnsmallcap_hist, hist_size - 1)

        // Calculate returns for market indices
        float ret_vnindex = f_compute_return(vnindex_now, vnindex_past)
        float ret_vn30 = f_compute_return(vn30_now, vn30_past)
        float ret_vn100 = f_compute_return(vn100_now, vn100_past)
        float ret_vnmidcap = f_compute_return(vnmidcap_now, vnmidcap_past)
        float ret_vnsmallcap = f_compute_return(vnsmallcap_now, vnsmallcap_past)

        // Update market indices stats (5 indices) - use PAST bucket
        f_update_return_stats(sumR_market, cntR_market, winR_market, 0 * 5 + past_bucket, ret_vnindex)
        f_update_return_stats(sumR_market, cntR_market, winR_market, 1 * 5 + past_bucket, ret_vn30)
        f_update_return_stats(sumR_market, cntR_market, winR_market, 2 * 5 + past_bucket, ret_vn100)
        f_update_return_stats(sumR_market, cntR_market, winR_market, 3 * 5 + past_bucket, ret_vnmidcap)
        f_update_return_stats(sumR_market, cntR_market, winR_market, 4 * 5 + past_bucket, ret_vnsmallcap)

        // Calculate R20 and R60 if enough history
        if hist_size >= 20
            float vnindex_20 = array.get(vnindex_hist, hist_size - 20)
            float ret_vnindex_20 = f_compute_return(vnindex_now, vnindex_20)
            f_update_return_stats(sumR20_market, cntR20_market, winR20_market, 0 * 5 + past_bucket, ret_vnindex_20)

            float vn30_20 = array.get(vn30_hist, hist_size - 20)
            float ret_vn30_20 = f_compute_return(vn30_now, vn30_20)
            f_update_return_stats(sumR20_market, cntR20_market, winR20_market, 1 * 5 + past_bucket, ret_vn30_20)

            // Calculate DD20 from last 20 bars
            var float[] vnindex_20bars = array.new_float(0)
            for j = 0 to 19
                if hist_size - 19 + j < hist_size
                    array.push(vnindex_20bars, array.get(vnindex_hist, hist_size - 19 + j))
            float dd20_vnindex = f_max_drawdown(vnindex_20bars)
            f_update_dd_stats(maxDD20_market, sumDD20_market, cntDD20_market, 0 * 5 + past_bucket, dd20_vnindex)

        if hist_size >= 60
            float vnindex_60 = array.get(vnindex_hist, hist_size - 60)
            float ret_vnindex_60 = f_compute_return(vnindex_now, vnindex_60)
            f_update_return_stats(sumR60_market, cntR60_market, array.new_float(25, 0.0), 0 * 5 + past_bucket, ret_vnindex_60)

            // Calculate DD60
            var float[] vnindex_60bars = array.new_float(0)
            for j = 0 to 59
                if hist_size - 59 + j < hist_size
                    array.push(vnindex_60bars, array.get(vnindex_hist, hist_size - 59 + j))
            float dd60_vnindex = f_max_drawdown(vnindex_60bars)
            array.set(maxDD60_market, 0 * 5 + past_bucket, math.max(array.get(maxDD60_market, 0 * 5 + past_bucket), dd60_vnindex))

        // Calculate sector returns and relative returns
        if not na(ret_vnindex)
            float vnfin_past = array.get(vnfin_hist, hist_size - regime_return_horizon - 1)
            float vnfin_now = array.get(vnfin_hist, hist_size - 1)
            float vnreal_past = array.get(vnreal_hist, hist_size - regime_return_horizon - 1)
            float vnreal_now = array.get(vnreal_hist, hist_size - 1)
            float vncons_past = array.get(vncons_hist, hist_size - regime_return_horizon - 1)
            float vncons_now = array.get(vncons_hist, hist_size - 1)
            float vnind_past = array.get(vnind_hist, hist_size - regime_return_horizon - 1)
            float vnind_now = array.get(vnind_hist, hist_size - 1)

            float ret_vnfin = f_compute_return(vnfin_now, vnfin_past)
            float ret_vnreal = f_compute_return(vnreal_now, vnreal_past)
            float ret_vncons = f_compute_return(vncons_now, vncons_past)
            float ret_vnind = f_compute_return(vnind_now, vnind_past)

            // Relative returns (sector - benchmark)
            float rr_vnfin = not na(ret_vnfin) ? ret_vnfin - ret_vnindex : na
            float rr_vnreal = not na(ret_vnreal) ? ret_vnreal - ret_vnindex : na
            float rr_vncons = not na(ret_vncons) ? ret_vncons - ret_vnindex : na
            float rr_vnind = not na(ret_vnind) ? ret_vnind - ret_vnindex : na

            // Update sector stats (4 sectors) - use PAST bucket
            f_update_return_stats(sumRR_sector, cntRR_sector, winRR_sector, 0 * 5 + past_bucket, rr_vnfin)
            f_update_return_stats(sumRR_sector, cntRR_sector, winRR_sector, 1 * 5 + past_bucket, rr_vnreal)
            f_update_return_stats(sumRR_sector, cntRR_sector, winRR_sector, 2 * 5 + past_bucket, rr_vncons)
            f_update_return_stats(sumRR_sector, cntRR_sector, winRR_sector, 3 * 5 + past_bucket, rr_vnind)

            // Calculate RR20 for sectors if enough history
            if hist_size >= 20
                float vnindex_20 = array.get(vnindex_hist, hist_size - 20)
                float ret_vnindex_20 = f_compute_return(vnindex_now, vnindex_20)

                float vnfin_20 = array.get(vnfin_hist, hist_size - 20)
                float ret_vnfin_20 = f_compute_return(vnfin_now, vnfin_20)
                float rr20_vnfin = not na(ret_vnfin_20) and not na(ret_vnindex_20) ? ret_vnfin_20 - ret_vnindex_20 : na
                f_update_return_stats(sumRR20_sector, cntRR20_sector, winRR20_sector, 0 * 5 + past_bucket, rr20_vnfin)

                float vnreal_20 = array.get(vnreal_hist, hist_size - 20)
                float ret_vnreal_20 = f_compute_return(vnreal_now, vnreal_20)
                float rr20_vnreal = not na(ret_vnreal_20) and not na(ret_vnindex_20) ? ret_vnreal_20 - ret_vnindex_20 : na
                f_update_return_stats(sumRR20_sector, cntRR20_sector, winRR20_sector, 1 * 5 + past_bucket, rr20_vnreal)

                float vncons_20 = array.get(vncons_hist, hist_size - 20)
                float ret_vncons_20 = f_compute_return(vncons_now, vncons_20)
                float rr20_vncons = not na(ret_vncons_20) and not na(ret_vnindex_20) ? ret_vncons_20 - ret_vnindex_20 : na
                f_update_return_stats(sumRR20_sector, cntRR20_sector, winRR20_sector, 2 * 5 + past_bucket, rr20_vncons)

                float vnind_20 = array.get(vnind_hist, hist_size - 20)
                float ret_vnind_20 = f_compute_return(vnind_now, vnind_20)
                float rr20_vnind = not na(ret_vnind_20) and not na(ret_vnindex_20) ? ret_vnind_20 - ret_vnindex_20 : na
                f_update_return_stats(sumRR20_sector, cntRR20_sector, winRR20_sector, 3 * 5 + past_bucket, rr20_vnind)


// POLICY PRESSURE CALCULATION

f_z_to_score(z) =>
    float score = 50.0 + 25.0 * z
    math.max(0.0, math.min(100.0, score))

f_apply_norm(percentile_val, z_val) =>
    float perc = percentile_val
    float zScore = na(z_val) ? na : f_z_to_score(z_val)
    if norm_mode == "Percentile"
        perc
    else if norm_mode == "Robust Z-score"
        zScore
    else
        not na(perc) and not na(zScore) ? (perc + zScore) / 2.0 : (not na(perc) ? perc : zScore)

// 1. Funding Pressure
float stress_risk_pct = ta.percentrank(tight_idx, percentile_lookback)
float funding_pressure = f_apply_norm(stress_risk_pct, f_z(tight_idx, rate_z_len_m, rate_clip))

// 2. Curve Pressure
float curve_risk_pct = na
float spread_risk_pct = na
float curve_component = na
float spread_component = na
float curve_pressure = na
if useYieldCurve
    curve_risk_pct := not na(yc_slope_m) ? (100.0 - ta.percentrank(yc_slope_m, percentile_lookback)) : na
    spread_risk_pct := not na(long_short_spread) ? (100.0 - ta.percentrank(long_short_spread, percentile_lookback)) : na
    curve_component := f_apply_norm(curve_risk_pct, -yc_idx)
    spread_component := f_apply_norm(spread_risk_pct, f_z(-long_short_spread, 60, 2.5))
    float curve_sum = 0.0
    float curve_cnt = 0.0
    if not na(curve_component)
        curve_sum += curve_component
        curve_cnt += 1.0
    if not na(spread_component)
        curve_sum += spread_component
        curve_cnt += 1.0
    curve_pressure := curve_cnt > 0 ? curve_sum / curve_cnt : na

// 3. External Pressure
float intl_risk_pct = na
float intl_component = na
if useYieldCurve and not na(intl_yield_diff)
    intl_risk_pct := 100.0 - ta.percentrank(intl_yield_diff, percentile_lookback)
    intl_component := f_apply_norm(intl_risk_pct, f_z(-intl_yield_diff, 60, 2.5))
float fed_gap_pct = na(fed_gap) ? na : ta.percentrank(fed_gap, percentile_lookback)
float fed_gap_z = na(fed_gap) ? na : f_z(fed_gap, 60, 2.5)
float fed_component = f_apply_norm(fed_gap_pct, fed_gap_z)
float external_pressure = na
if true
    float external_sum = 0.0
    float external_cnt = 0.0
    if not na(intl_component)
        external_sum += intl_component
        external_cnt += 1.0
    if not na(fed_component)
        external_sum += fed_component
        external_cnt += 1.0
    external_pressure := external_cnt > 0 ? external_sum / external_cnt : na

// 4. FX Pressure
float fx_yoy_pct = na(fx_yoy_abs) ? na : ta.percentrank(fx_yoy_abs, percentile_lookback)
float fx_vol_pct = na(fx_vol_3m) ? na : ta.percentrank(fx_vol_3m, percentile_lookback)
float fx_yoy_z = na(fx_yoy_abs) ? na : f_z(fx_yoy_abs, 60, 2.5)
float fx_vol_z = na(fx_vol_3m) ? na : f_z(fx_vol_3m, 60, 2.5)
float fx_yoy_component = f_apply_norm(fx_yoy_pct, fx_yoy_z)
float fx_vol_component = f_apply_norm(fx_vol_pct, fx_vol_z)
float fx_pressure_core = na
if true
    float fx_sum = 0.0
    float fx_cnt = 0.0
    if not na(fx_yoy_component)
        fx_sum += fx_yoy_component
        fx_cnt += 1.0
    if not na(fx_vol_component)
        fx_sum += fx_vol_component
        fx_cnt += 1.0
    fx_pressure_core := fx_cnt > 0 ? fx_sum / fx_cnt : na
float fx_pressure_idx = not na(fx_pressure_core) ? math.max(0.0, math.min(100.0, fx_pressure_core * fx_shock_mult)) : na

// 5. COMPOSITE POLICY PRESSURE (weighted average)
float w_fp_eff = w_fp
float w_cp_eff = w_cp
float fed_z_pos = na(fed_gap_z) ? 0.0 : math.max(0.0, fed_gap_z)
float w_ep_eff = external_weight_mode == "Fed-sensitive" ? (w_ep + fed_z_pos * 0.1) : w_ep
float w_fx_eff = w_fx_pressure

float policy_pressure = na
if true
    float pressure_num = 0.0
    float pressure_den = 0.0
    if not na(funding_pressure)
        pressure_num += funding_pressure * w_fp_eff
        pressure_den += w_fp_eff
    if not na(curve_pressure)
        pressure_num += curve_pressure * w_cp_eff
        pressure_den += w_cp_eff
    if not na(external_pressure)
        pressure_num += external_pressure * w_ep_eff
        pressure_den += w_ep_eff
    if not na(fx_pressure_idx)
        pressure_num += fx_pressure_idx * w_fx_eff
        pressure_den += w_fx_eff
    policy_pressure := pressure_den > 0 ? pressure_num / pressure_den : na

// ZONE CLASSIFICATION
string pressure_zone = "NEUTRAL"
if not na(policy_pressure)
    if policy_pressure >= zone_high_pct
        pressure_zone := "HIGH"
    else if policy_pressure <= zone_low_pct
        pressure_zone := "LOW"
    else
        pressure_zone := "NEUTRAL"

// SCENARIO ANALYSIS
bool fx_stress_high = not na(fx_pressure_idx) and fx_pressure_idx > 70
bool fed_gap_stress = not na(fed_gap) and fed_gap > 2.0
bool policy_press_high = not na(policy_pressure) and policy_pressure >= zone_high_pct

bool scenario_liquidity_crisis = stress_high and curve_inversion and (intl_warning or fx_stress_high)
bool scenario_growth_slowdown = growth_low and drivers_high and spread_warning
bool scenario_inflation_surge = inflation_high and external_stress and drivers_high
bool scenario_stagflation = inflation_high and growth_low and stress_high
bool scenario_soft_landing = macro_improving and not inflation_high and not stress_high
bool scenario_bull_market = bullish_divergence and is_cheap and macro_improving
bool scenario_bear_market = risk_pct > 70 and macro_deteriorating and not is_cheap
bool scenario_credit_bubble = credit_high and inflation_high and valuation_distance > 1.2
bool scenario_fx_crisis = fx_stress_high and intl_warning and (fed_gap_stress or policy_press_high)

string scenario_name = "BÃ¬nh thÆ°á»ng"
int scenario_severity = 0  // 0=neutral, 1=caution, 2=warning, 3=danger, 4=opportunity

if scenario_bull_market
    scenario_name := "CÆ  Há»˜I MUA\nPhÃ¢n ká»³ tÃ­ch cá»±c"
    scenario_severity := 4
else if scenario_fx_crisis
    scenario_name := "FX Stress"
    scenario_severity := 3
else if scenario_liquidity_crisis
    scenario_name := "KHá»¦NG HOáº¢NG THANH KHOáº¢N"
    scenario_severity := 3
else if scenario_stagflation
    scenario_name := "STAGFLATION\nLáº¡m phÃ¡t\nTÄƒng trÆ°á»Ÿng yáº¿u"
    scenario_severity := 3
else if scenario_credit_bubble
    scenario_name := "Bá»˜T TÃŒNH Dá»¤NG\nQuÃ¡ nÃ³ng"
    scenario_severity := 3
else if scenario_bear_market
    scenario_name := "THá»Š TRÆ¯á»œNG Xáº¤U ÄI"
    scenario_severity := 2
else if scenario_inflation_surge
    scenario_name := "ÃP Lá»°C Láº M PHÃT"
    scenario_severity := 2
else if scenario_growth_slowdown
    scenario_name := "TÄ‚NG TRÆ¯á»žNG CHáº¬M Láº I"
    scenario_severity := 2
else if scenario_soft_landing
    scenario_name := "Háº  CÃNH Má»€M\nTÃ­ch cá»±c"
    scenario_severity := 1

// P) PERFORMANCE TRACKING

float perf_accuracy = na(risk_pct) or na(risk_pct[12]) ? na : math.abs(risk_pct - risk_pct[12]) < 5 ? 95.0 : math.abs(risk_pct - risk_pct[12]) < 10 ? 85.0 : 75.0

// EVALUATION MODULE
float mae24_m   = na
float rmse24_m  = na
if not na(surprise_m)
    mae24_m  := ta.sma(math.abs(surprise_m), 24)
    rmse24_m := math.sqrt(ta.sma(surprise_m * surprise_m, 24))

int stateId = 0
bool hasDataP1 = not na(pi_m) and not na(pi_trend_m) and not na(pi_e_m) and not na(pi_gap_m) and not na(dpi_m) and not na(surprise_m)

bool cond_hot  = hasDataP1 and (dpi_m > 0) and ((pi_gap_m > 0) or (surprise_m > 0))
bool cond_cool = hasDataP1 and (pi_gap_m < 0) and (dpi_m < 0)

stateId := hasDataP1 ? (cond_hot ? 1 : (cond_cool ? -1 : 0)) : 0
float churn12 = f_rollsum(stateId != stateId[1] ? 1.0 : 0.0, 12)

// Q) PCTL PACK (arrays)

var float[] arr_m2 = array.new_float()
var float[] arr_m2gap = array.new_float()
var float[] arr_credit_idx = array.new_float()
var float[] arr_dxy = array.new_float()
var float[] arr_valuation = array.new_float()

var float[] arr_pi     = array.new_float()
var float[] arr_epi    = array.new_float()
var float[] arr_gap    = array.new_float()
var float[] arr_dpi    = array.new_float()
var float[] arr_sur    = array.new_float()
var float[] arr_ipol   = array.new_float()
var float[] arr_iib    = array.new_float()
var float[] arr_rreal  = array.new_float()
var float[] arr_tight  = array.new_float()
var float[] arr_polgap = array.new_float()
var float[] arr_gdp    = array.new_float()
var float[] arr_gdpgap = array.new_float()
var float[] arr_grow   = array.new_float()
var float[] arr_yc     = array.new_float()
var float[] arr_ycidx  = array.new_float()
var float[] arr_sinfl  = array.new_float()
var float[] arr_spol   = array.new_float()
var float[] arr_sgrow  = array.new_float()
var float[] arr_sdrv   = array.new_float()

var float[] arr_risk_pct     = array.new_float()
var float[] arr_risk_forecast = array.new_float()
var float[] arr_layer1       = array.new_float()
var float[] arr_layer2       = array.new_float()
var float[] arr_layer3       = array.new_float()
var float[] arr_intl_diff    = array.new_float()
var float[] arr_long_short   = array.new_float()
f_arr_push_float(float[] arr, float val, int maxlen) =>
    if not na(val)
        array.push(arr, val)
        if array.size(arr) > maxlen
            array.shift(arr)
if isNewMonth
    f_arr_push_float(arr_risk_pct, risk_pct, 500)
    f_arr_push_float(arr_pi, pi_m, 500)
    f_arr_push_float(arr_epi, pi_e_m, 500)
    f_arr_push_float(arr_gap, pi_gap_m, 500)
    f_arr_push_float(arr_dpi, dpi_m, 500)
    f_arr_push_float(arr_sur, surprise_m, 500)
    f_arr_push_float(arr_ipol, i_policy_m, 500)
    f_arr_push_float(arr_iib, i_ib_m, 500)
    f_arr_push_float(arr_rreal, r_real_m, 500)
    f_arr_push_float(arr_tight, tight_idx, 500)
    f_arr_push_float(arr_polgap, policy_gap, 500)
    f_arr_push_float(arr_gdp, gdp_q, 500)
    f_arr_push_float(arr_gdpgap, gdp_gap_q, 500)
    f_arr_push_float(arr_grow, grow_idx, 500)
    if useYieldCurve
        f_arr_push_float(arr_yc, yc_slope_m, 500)
        f_arr_push_float(arr_ycidx, yc_idx, 500)
    f_arr_push_float(arr_sinfl, S_infl, 500)
    f_arr_push_float(arr_spol, S_pol, 500)
    f_arr_push_float(arr_sgrow, S_grow, 500)
    f_arr_push_float(arr_sdrv, S_drv, 500)
    f_arr_push_float(arr_risk_forecast, risk_forecast, 500)
    f_arr_push_float(arr_layer1, layer1_score, 500)
    f_arr_push_float(arr_layer2, layer2_score, 500)
    f_arr_push_float(arr_layer3, layer3_score, 500)
    f_arr_push_float(arr_intl_diff, intl_yield_diff, 500)
    f_arr_push_float(arr_long_short, long_short_spread, 500)
    if useCredit
        f_arr_push_float(arr_m2, m2_yoy_m, 500)
        f_arr_push_float(arr_m2gap, m2_gap_m, 500)
        f_arr_push_float(arr_credit_idx, credit_idx, 500)
    if useDXY
        f_arr_push_float(arr_dxy, dxy_m, 500)
    if useValuation
        f_arr_push_float(arr_valuation, valuation_distance, 500)
    // Evaluation arrays
f_arr_pctl(float[] arr, float val) =>
    float p = na
    int n = array.size(arr)
    if n > 0 and not na(val)
        int cnt = 0
        for i = 0 to n - 1
            float x = array.get(arr, i)
            if not na(x) and x <= val
                cnt += 1
        p := 100.0 * cnt / n
    p
float p_pi      = f_arr_pctl(arr_pi, pi_m)
float p_epi     = f_arr_pctl(arr_epi, pi_e_m)
float p_gap     = f_arr_pctl(arr_gap, pi_gap_m)
float p_dpi     = f_arr_pctl(arr_dpi, dpi_m)
float p_sur     = f_arr_pctl(arr_sur, surprise_m)
float p_ipol    = f_arr_pctl(arr_ipol, i_policy_m)
float p_iib     = f_arr_pctl(arr_iib, i_ib_m)
float p_rreal   = f_arr_pctl(arr_rreal, r_real_m)
float p_tight   = f_arr_pctl(arr_tight, tight_idx)
float p_polgap  = f_arr_pctl(arr_polgap, policy_gap)
float p_gdp     = f_arr_pctl(arr_gdp, gdp_q)
float p_gdpgap  = f_arr_pctl(arr_gdpgap, gdp_gap_q)
float p_grow    = f_arr_pctl(arr_grow, grow_idx)
float p_yc      = useYieldCurve ? f_arr_pctl(arr_yc, yc_slope_m) : na
float p_ycidx   = useYieldCurve ? f_arr_pctl(arr_ycidx, yc_idx) : na
float p_sinfl   = f_arr_pctl(arr_sinfl, S_infl)
float p_spol    = f_arr_pctl(arr_spol, S_pol)
float p_sgrow   = f_arr_pctl(arr_sgrow, S_grow)
float p_sdrv    = f_arr_pctl(arr_sdrv, S_drv)
float p_risk    = f_arr_pctl(arr_risk_pct, risk_pct)
float p_risk_forecast = f_arr_pctl(arr_risk_forecast, risk_forecast)
float p_layer1  = f_arr_pctl(arr_layer1, layer1_score)
float p_layer2  = f_arr_pctl(arr_layer2, layer2_score)
float p_layer3  = f_arr_pctl(arr_layer3, layer3_score)
float p_intl    = useYieldCurve ? f_arr_pctl(arr_intl_diff, intl_yield_diff) : na
float p_spread  = useYieldCurve ? f_arr_pctl(arr_long_short, long_short_spread) : na
float p_m2 = useCredit ? f_arr_pctl(arr_m2, m2_yoy_m) : na
float p_m2gap = useCredit ? f_arr_pctl(arr_m2gap, m2_gap_m) : na
float p_credit = useCredit ? f_arr_pctl(arr_credit_idx, credit_idx) : na
float p_dxy = useDXY ? f_arr_pctl(arr_dxy, dxy_m) : na
float p_valuation = useValuation ? f_arr_pctl(arr_valuation, valuation_distance) : na

string infl_state = not hasDataP1 ? "No data" : (cond_cool ? "Äang háº¡ nhiá»‡t" : (cond_hot ? "CÃ³ dáº¥u hiá»‡u nÃ³ng láº¡i" : "Di ngang"))

string stance_vi = "Lai suat: trung tinh"
if not hasDataP1
    stance_vi := "Lai suat: chua ro"
else if (r_real_gap_m > 0) or (not na(p_tight) and p_tight >= 80)
    stance_vi := "Lai suat: dang that"
else if (r_real_gap_m < 0) or (not na(p_tight) and p_tight <= 40)
    stance_vi := "Lai suat: dang de"

string phase_vi = "Pha: on dinh"
if not na(grow_idx)
    phase_vi := grow_idx > 0.5 ? "Pha: mo rong" : (grow_idx < -0.5 ? "Pha: cham lai" : "Pha: on dinh")


string yc_vi  = useYieldCurve ? ((not na(yc_slope_m) and yc_slope_m < 0) ? "YC: dao nguoc" : "YC: binh thuong") : "YC: OFF"
string eval_vi = ((not na(mae24_m) and mae24_m < 0.20 and not na(churn12) and churn12 <= 2) ? "Tin hieu: on dinh" : "Tin hieu: de doi")


// O) PLOTS
// P1: Inflation (merged P1+P4)
plot(panel==1 ? pi_trend_m : na, "P1 Trend", linewidth=2, color=color.gray)
plot(panel==1 ? pi_gap_m   : na, "P1 Gap",   style=plot.style_area, color=color.new(color.orange, 80))
plot(panel==1 ? pi_m       : na, "P1 Inflation",   linewidth=2, trackprice=false, color=color.purple)
hline(panel==1 ? pi_target : na, 'P1 Inflation target', color=color.red, linestyle=hline.style_dashed)

if panel==1 and barstate.islast
    f_setLabel(na, bar_index + 10, pi_m ,"Inflation",color.purple)
    f_setLabel(na, bar_index + 20, pi_trend_m ,"Trend",color.orange)

// P2: Rates & Liquidity
plot(panel==2 ? tight_idx  : na, "P2 TightIdx", style=plot.style_area, color=color.new(color.red, 80))
plot(panel==2 ? i_policy_m : na, "P2 Policy", linewidth=2, trackprice=false, color=color.black)
plot(panel==2 ? i_ib_m     : na, "P2 IB",     linewidth=2, trackprice=false, color=color.red)
plot(panel==2 ? vn10y_m : na, "P2 VN 10Y", linewidth=1, color=color.lime)
plot(panel==2 ? vn02y_m : na, "P2 VN 02Y", linewidth=1, color=color.yellow)

vn_yc = vn10y_m - vn02y_m
plot(panel==2 ? vn_yc : na, "P2 VN YC", linewidth=1, color=color.black)
plot(panel==2 ? intl_yield_diff : na, "P4 VN-US Diff", linewidth=1, color=color.orange)
plot(panel==2 ? long_short_spread : na, "P4 Long-Short", linewidth=1, color=color.aqua)

if panel==2 and barstate.islast
    f_setLabel(na, bar_index + 10, i_policy_m ,"Policy",color.black)
    f_setLabel(na, bar_index + 5, i_ib_m ,"Interbank",color.red)
    f_setLabel(na, bar_index + 15, long_short_spread ,"10Y-Policy",color.aqua)
    f_setLabel(na, bar_index + 20, intl_yield_diff ,"VN-US",color.orange)
    f_setLabel(na, bar_index + 10, vn_yc ,"YC",color.black)

// P3: GDP Growth
plot(panel==3 ? gdp_gap_q   : na, "P3 GDP gap", style=plot.style_area, color=color.new(color.purple, 80))
plot(panel==3 ? gdp_q       : na, "P3 GDP", linewidth=2, trackprice=false, color=color.black)
plot(panel==3 ? gdp_trend_q : na, "P3 GDP trend", linewidth=1, color=color.red)

// P4: Yield Curve Analysis
plot(panel==4 ? yc_idx     : na, "P4 YC idx", style=plot.style_area, color=color.new(color.gray, 80))
plot(panel==4 ? yc_slope_m : na, "P4 YC slope", linewidth=2, trackprice=false, color=color.black)
plot(panel==4 ? vn10y_d : na, "P4 VN10Y", linewidth=2, color=color.green)
plot(panel==4 ? vn05y_d : na, "P4 VN05Y", linewidth=1, color=color.blue)
plot(panel==4 ? vn02y_d : na, "P4 VN02Y", linewidth=1, color=color.red)
plot(panel==4 ? intl_yield_diff : na, "P4 VN-US Diff", linewidth=1, color=color.orange)
plot(panel==4 ? long_short_spread : na, "P4 Long-Short", linewidth=1, color=color.aqua)
if panel==4 and barstate.islast
    f_setLabel(na, bar_index + 10, long_short_spread ,"10Y-Policy",color.aqua)
    f_setLabel(na, bar_index + 20, intl_yield_diff ,"VN-US",color.orange)

// YC Stress overlay (mapped to yield range)
float yc_y_min = use_yc_lab and panel==4 ? ta.lowest(math.min(vn02y_d, math.min(vn05y_d, vn10y_d)), yc_stats_len) : na
float yc_y_max = use_yc_lab and panel==4 ? ta.highest(math.max(vn02y_d, math.max(vn05y_d, vn10y_d)), yc_stats_len) : na
float yc_y_range = not na(yc_y_max) and not na(yc_y_min) ? yc_y_max - yc_y_min : 1.0
float yc_stress_mapped = use_yc_lab and panel==4 and not na(yc_stress_adj) ? yc_y_min + (yc_stress_adj / 100.0) * yc_y_range : na
plot(panel==4 ? yc_stress_mapped : na, "P4 YC Stress", linewidth=2, color=color.new(color.white, 30))
color yc_bg = use_yc_lab and panel==4 and yc_quality_label == "LOWQ" ? color.new(color.red, 92) :
              use_yc_lab and panel==4 and yc_quality_label == "HIGHQ" ? color.new(color.green, 92) : na
bgcolor(panel==4 ? yc_bg : na, title="P4 Quality BG")

// P5: RiskScore & Forecast
plot(panel==5 ? risk_pct : na, "P5 Risk %", linewidth=3, color=color.red)
plot(panel==5 ? risk_forecast : na, "P5 Forecast", linewidth=2, color=color.yellow, style=plot.style_linebr)
hline(panel==5 ? 60 : na, "High Risk", color=color.orange, linestyle=hline.style_dashed)
hline(panel==5 ? 40 : na, "Low Risk", color=color.green, linestyle=hline.style_dashed)
hline(panel==5 ? 20 : na, "B0-B1", color=color.gray, linestyle=hline.style_dotted)
hline(panel==5 ? 80 : na, "B3-B4", color=color.gray, linestyle=hline.style_dotted)
bgcolor(panel==5 ? f_bucket_bg(current_bucket) : na, title="P5 Regime BG")

// P6: Credit Growth
plot(panel==6 ? credit_idx : na, "P6 Credit Idx", style=plot.style_area, color=color.new(color.purple, 80))
plot(panel==6 ? m2_yoy_m : na, "P6 M2 YoY", linewidth=2, trackprice=false, color=color.black)

// P7: Valuation & Divergence
plot(panel==7 ? valuation_distance * 100 : na, "P7 Valuation %", linewidth=2, color=color.blue)
plot(panel==7 ? risk_pct : na, "P7 Risk %", linewidth=2, color=color.red)
hline(panel==7 ? valuation_discount * 100 : na, "Cheap Threshold", color=color.green, linestyle=hline.style_dashed)
plotshape(panel==7 and bullish_divergence, "Bullish Divergence", shape.labelup, location.bottom, color.green, text="BUY?", textcolor=color.white, size=size.small)

// P8: Policy Pressure
plot(panel==8 ? policy_pressure : na, "P8 Policy Pressure", linewidth=3, color=color.white)
plot(panel==8 ? funding_pressure : na, "P8 Funding", linewidth=2, color=color.red)
plot(panel==8 ? curve_pressure : na, "P8 Curve", linewidth=2, color=color.orange)
plot(panel==8 ? external_pressure : na, "P8 External", linewidth=2, color=color.blue)
plot(panel==8 ? fx_pressure_idx : na, "P8 FX", linewidth=2, color=color.purple)

if panel==8 and barstate.islast
    f_setLabel(na, bar_index + 10, policy_pressure ,"Policy Pressure",color.black)
    f_setLabel(na, bar_index + 10, curve_pressure ,"Curve Pressure",color.orange)

hline(panel==8 ? zone_high_pct : na, 'High Zone', color=color.red, linestyle=hline.style_dashed)
hline(panel==8 ? zone_low_pct : na, 'Low Zone', color=color.green, linestyle=hline.style_dashed)
hline(panel==8 ? 50 : na, 'Neutral', color=color.gray, linestyle=hline.style_dotted)
bgcolor(panel==8 and not na(policy_pressure) and policy_pressure >= zone_high_pct ? color.new(color.red, 90) :
         panel==8 and not na(policy_pressure) and policy_pressure <= zone_low_pct ? color.new(color.green, 90) : na, title="P8 Zone BG")

// P9: Market & Sector
plot(panel==9 ? risk_pct : na, "P9 Risk %", linewidth=2, color=color.orange)
hline(panel==9 ? 20 : na, "B0-B1", color=color.gray, linestyle=hline.style_dotted)
hline(panel==9 ? 40 : na, "B1-B2", color=color.gray, linestyle=hline.style_dotted)
hline(panel==9 ? 60 : na, "B2-B3", color=color.gray, linestyle=hline.style_dotted)
hline(panel==9 ? 80 : na, "B3-B4", color=color.gray, linestyle=hline.style_dotted)
bgcolor(panel==9 ? f_bucket_bg(current_bucket) : na, title="P9 Bucket BG")



// P10: US Yield Curve Analysis
plot(panel==10 ? us_yc_slope : na, "P10 US YC Slope", linewidth=2, trackprice=false, color=color.black)
plot(panel==10 ? us10y_m : na, "P10 US 10Y", linewidth=2, color=color.red)
plot(panel==10 ? us02y_m : na, "P10 US 02Y", linewidth=1, color=color.blue)
plot(panel==10 ? fed_policy_rate_m : na, "P10 Fed Rate", linewidth=2, color=color.orange, style=plot.style_stepline)
if panel==8 and barstate.islast
    f_setLabel(na, bar_index + 10, fed_policy_rate_m ,"Fed",color.orange)


// --- KHAI BÃO BIáº¾N TRáº NG THÃI ---
var float entry_price = na
var float stop_loss = na
var float take_profit = na

string action = "wait"

bool strong_buy = bullish_divergence and is_cheap and risk_pct < 50
bool weak_buy   = macro_improving and risk_pct < 40 and not is_cheap

// --- Xá»¬ LÃ LOGIC TRáº NG THÃI (STATE MACHINE) ---

// 1. Kiá»ƒm tra náº¿u ÄANG CÃ“ Lá»†NH (Position Open)
if not na(entry_price)
    // Kiá»ƒm tra Cáº¯t lá»— (Stop Loss)
    if vnindex_m <= stop_loss
        action := "stop_loss"
        entry_price := na
        stop_loss := na
        take_profit := na

    // Kiá»ƒm tra Chá»‘t lá»i (Take Profit)
    else if vnindex_m >= take_profit
        action := "take_profit"
        entry_price := na
        stop_loss := na
        take_profit := na

    // Kiá»ƒm tra TÃ­n hiá»‡u thoÃ¡t lá»‡nh do rá»§i ro (Risk Exit)
    else if risk_pct > 70
        action := "risk_exit" // ThoÃ¡t do rá»§i ro cao
        entry_price := na
        stop_loss := na
        take_profit := na

    // Náº¿u khÃ´ng cháº¡m Ä‘iá»u kiá»‡n nÃ o á»Ÿ trÃªn -> Tiáº¿p tá»¥c giá»¯ (Hold)
    else
        action := "hold"

// 2. Kiá»ƒm tra náº¿u CHÆ¯A CÃ“ Lá»†NH (No Position)
else
    if strong_buy
        action := "strong_buy"
        entry_price := vnindex_m
        stop_loss := entry_price * 0.92   // 8% stop
        take_profit := entry_price * 1.25 // 25% target

    else if weak_buy
        action := "weak_buy"
        entry_price := vnindex_m
        stop_loss := entry_price * 0.95   // VÃ­ dá»¥: weak buy stop loss cháº·t hÆ¡n (5%)
        take_profit := entry_price * 1.10 // Target nhá» hÆ¡n

f_display_header(int offset) =>

    string status_line = ""
    status_line += useValuation ? (is_cheap ? "ðŸ’° GIÃ Ráºº" : "ðŸ’¸ Äáº®T") : ""
    status_line += bullish_divergence ? (status_line != "" ? " | " : "") + "ðŸ“ˆ PHÃ‚N Ká»²+" : ""
    status_line += macro_improving ? (status_line != "" ? " | " : "") + "âœ… VI MÃ”+" : macro_deteriorating ? (status_line != "" ? " | " : "") + "âš ï¸ VI MÃ”-" : ""
    status_line += action != "wait" ? (status_line != "" ? " | " : "") + "" + action : ""

    int row_offset = offset
    string head_txt = status_line + "|" + f_bucket_label(risk_bucket) + " | Risk: " + f_fmt(risk_pct,1) + "% â†’ " + f_fmt(risk_forecast,1) + "%"
    color head_bg = f_bucket_bg(risk_bucket)
    f_cell(0, 0, head_txt, head_bg, color.black, text.align_center)
    table.merge_cells(t, 0, 0, 3, 0)

    // MACRO WEATHER SUMMARY (4 PILLARS)
    f_hdr(row_offset, "MACRO WEATHER SUMMARY")
    row_offset += 1

    // Pillar 1: Liquidity/Funding
    string p1_icon = stress_high ? "ðŸ”´" : "ðŸŸ¢"
    string p1_label = "1ï¸âƒ£ Thanh khoáº£n"
    string p1_status = stress_high ? "CÄ‚NG THáº²NG" : "á»”N Äá»ŠNH"
    color p1_bg = stress_high ? color.new(color.red,70) : color.new(color.green,75)
    float p1_strength = stress_high ? 80.0 : 20.0  // High stress = high risk
    color p1_text_color = p1_strength > 60 ? color.white : color.black

    f_cell(row_offset, 0, p1_icon + " " + p1_label, color.new(color.blue,85), color.black, text.align_left)
    f_cell(row_offset, 1, p1_status, p1_bg, p1_text_color, text.align_center)

    // Pillar 2: Growth/Cycle
    string p2_icon = growth_low ? "ðŸ”´" : "ðŸŸ¢"
    string p2_label = "2ï¸âƒ£ TÄƒng trÆ°á»Ÿng"
    string p2_status = growth_low ? "Yáº¾U" : "Máº NH"
    color p2_bg = growth_low ? color.new(color.red,70) : color.new(color.green,75)
    float p2_strength = growth_low ? 75.0 : 25.0
    color p2_text_color = p2_strength > 60 ? color.white : color.black

    f_cell(row_offset, 2, p2_icon + " " + p2_label, color.new(color.blue,85), color.black, text.align_left)
    f_cell(row_offset, 3, p2_status, p2_bg, p2_text_color, text.align_center)
    row_offset += 1

    // Pillar 3: Inflation
    string p3_icon = inflation_high ? "ðŸ”´" : "ðŸŸ¢"
    string p3_label = "3ï¸âƒ£ Láº¡m phÃ¡t"
    string p3_status = inflation_high ? "CAO" : "á»”N Äá»ŠNH"
    color p3_bg = inflation_high ? color.new(color.red,70) : color.new(color.green,75)
    float p3_strength = inflation_high ? 85.0 : 15.0
    color p3_text_color = p3_strength > 60 ? color.white : color.black

    f_cell(row_offset, 0, p3_icon + " " + p3_label, color.new(color.blue,85), color.black, text.align_left)
    f_cell(row_offset, 1, p3_status, p3_bg, p3_text_color, text.align_center)

    // Pillar 4: Yield Curve/External
    string p4_icon = curve_inversion ? "ðŸ”´" : "ðŸŸ¢"
    string p4_label = "4ï¸âƒ£ ÄÆ°á»ng cong"
    string p4_status = curve_inversion ? "Äáº¢O NGÆ¯á»¢C" : "BÃŒNH THÆ¯á»œNG"
    color p4_bg = curve_inversion ? color.new(color.red,70) : color.new(color.green,75)
    float p4_strength = curve_inversion ? 90.0 : 10.0
    color p4_text_color = p4_strength > 60 ? color.white : color.black

    f_cell(row_offset, 2, p4_icon + " " + p4_label, color.new(color.blue,85), color.black, text.align_left)
    f_cell(row_offset, 3, p4_status, p4_bg, p4_text_color, text.align_center)
    row_offset += 1

    // Overall Weather Assessment
    int risk_count = (stress_high ? 1 : 0) + (growth_low ? 1 : 0) + (inflation_high ? 1 : 0) + (curve_inversion ? 1 : 0)
    string weather_icon = risk_count == 0 ? "â˜€ï¸ " : risk_count == 1 ? "â›… " : risk_count == 2 ? "ðŸŒ¥ " : risk_count == 3 ? "â›ˆ " : "ðŸŒª "
    string weather_status = risk_count == 0 ? "HOÃ€N Háº¢O - Táº¥t cáº£ trá»¥ cá»™t lÃ nh máº¡nh" :
                           risk_count == 1 ? "Tá»T - 1 trá»¥ cá»™t cÃ³ rá»§i ro" :
                           risk_count == 2 ? "Cáº¨N TRá»ŒNG - 2 trá»¥ cá»™t cÃ³ rá»§i ro" :
                           risk_count == 3 ? "Cáº¢NH BÃO - 3 trá»¥ cá»™t cÃ³ rá»§i ro" :
                           "NGUY HIá»‚M - Táº¥t cáº£ trá»¥ cá»™t cÃ³ rá»§i ro"
    color weather_bg = risk_count == 0 ? color.new(color.green,55) :
                      risk_count == 1 ? color.new(color.green,70) :
                      risk_count == 2 ? color.new(color.orange,65) :
                      risk_count == 3 ? color.new(color.red,65) :
                      color.new(color.red,50)

    f_cell(row_offset, 0, weather_icon + "Tá»•ng quan:", color.new(color.purple,70), color.black, text.align_left)
    f_cell(row_offset, 1, weather_status, weather_bg, color.black, text.align_left)
    table.merge_cells(t, 1, row_offset, 3, row_offset)
    row_offset += 1

    row_offset += 1
    f_cell(row_offset, 0, "PCTL: 50=bÃ¬nh thÆ°á»ng, 80+=cao", color.new(color.gray, 88), color.new(color.black, 0), text.align_left)
    table.merge_cells(t, 0, row_offset, 1, row_offset)
    f_cell(row_offset, 2, "Buckets: B0(ráº¥t tháº¥p)â†’B4(ráº¥t cao)", color.new(color.gray, 88), color.new(color.black, 0), text.align_left)
    table.merge_cells(t, 2, row_offset, 3, row_offset)
    row_offset += 1
    row_offset

// Display signal dashboard
f_display_signals(int offset) =>
    int row_offset = offset
    f_hdr(row_offset, "TÃN HIá»†U VÄ¨ MÃ” CHÃNH")
    row_offset += 1

    f_cell(row_offset, 0, "Thanh khoáº£n", color.new(color.blue,80), color.black, text.align_left)
    string liq_status = stress_high ? "ðŸ”´ CÄ‚NG" : "ðŸŸ¢ á»”N"
    f_cell(row_offset, 1, liq_status, stress_high ? color.new(color.red,70) : color.new(color.green,70), color.black, text.align_center)
    f_cell(row_offset, 2, "ðŸ“‰ ÄÆ°á»ng cong", color.new(color.blue,80), color.black, text.align_left)
    string yc_status = curve_inversion ? "ðŸ”´ Äáº¢O" : "ðŸŸ¢ BT"
    f_cell(row_offset, 3, yc_status, curve_inversion ? color.new(color.red,70) : color.new(color.green,70), color.black, text.align_center)
    row_offset += 1

    f_cell(row_offset, 0, "TÄƒng trÆ°á»Ÿng", color.new(color.blue,80), color.black, text.align_left)
    string growth_status = growth_low ? "ðŸ”´ Yáº¾U" : "ðŸŸ¢ Máº NH"
    f_cell(row_offset, 1, growth_status, growth_low ? color.new(color.red,70) : color.new(color.green,70), color.black, text.align_center)
    f_cell(row_offset, 2, "ðŸ”¥ Láº¡m phÃ¡t", color.new(color.blue,80), color.black, text.align_left)
    string infl_status = inflation_high ? "ðŸ”´ CAO" : "ðŸŸ¢ á»”N"
    f_cell(row_offset, 3, infl_status, inflation_high ? color.new(color.red,70) : color.new(color.green,70), color.black, text.align_center)
    row_offset += 1

    if useCredit or useValuation
        if useCredit
            f_cell(row_offset, 0, "TÃ­n dá»¥ng", color.new(color.blue,80), color.black, text.align_left)
            string credit_status = credit_high ? "ðŸŸ¡ NÃ“NG" : "ðŸŸ¢ á»”N"
            string credit_value = credit_high ? credit_status + " (" + f_fmt(m2_yoy_m,1) + "%)" : credit_status
            f_cell(row_offset, 1, credit_value, credit_high ? color.new(color.orange,70) : color.new(color.green,70), color.black, text.align_center)
        if useValuation
            int val_col = useCredit ? 2 : 0
            f_cell(row_offset, val_col, "Äá»‹nh giÃ¡", color.new(color.blue,80), color.black, text.align_left)
            string val_status = is_cheap ? "ðŸŸ¢ Ráºº" : "ðŸ”´ Äáº®T"
            string val_value = val_status + " (" + f_fmt(valuation_distance*100,1) + "%)"
            f_cell(row_offset, val_col+1, val_value, is_cheap ? color.new(color.green,70) : color.new(color.red,70), color.black, text.align_center)
        row_offset += 1

    if useDXY and dxy_stress > 0
        f_cell(row_offset, 0, "DXY Alert", color.new(color.orange,70), color.black, text.align_left)
        f_cell(row_offset, 1, "âš ï¸ >105 (" + f_fmt(dxy_m,1) + ")", color.new(color.red,70), color.black, text.align_center)
        table.merge_cells(t, 1, row_offset, 3, row_offset)
        row_offset += 1
    row_offset



// Display macro indicators (trend, divergence, policy pressure)
f_display_macro_indicators(int offset) =>
    int row_offset = offset
    f_cell(row_offset, 0, "Xu hÆ°á»›ng VI MÃ”", color.new(color.purple,75), color.black, text.align_left)
    string reversal_icon = macro_improving ? "ðŸ“ˆ " : macro_deteriorating ? "ðŸ“‰ " : "âž¡ï¸ "
    string reversal_status = macro_improving ? reversal_icon + "Cáº¢I THIá»†N" : macro_deteriorating ? reversal_icon + "Xáº¤U ÄI" : reversal_icon + "á»”N Äá»ŠNH"
    color reversal_color = macro_improving ? color.new(color.green,65) : macro_deteriorating ? color.new(color.red,65) : color.new(color.black,70)
    f_cell(row_offset, 1, reversal_status, reversal_color, color.black, text.align_center)



    if not na(policy_pressure)
        f_cell(row_offset, 2, "Ãp lá»±c CS", color.new(color.purple,75), color.black, text.align_left)
        string pressure_icon = pressure_zone == "HIGH" ? "ðŸ”´ " : pressure_zone == "LOW" ? "ðŸŸ¢ " : "ðŸŸ¡ "
        string pressure_summary = pressure_icon + pressure_zone + " (" + f_fmt(policy_pressure,0) + "%)"
        color pressure_summary_color = pressure_zone == "HIGH" ? color.new(color.red,65) : pressure_zone == "LOW" ? color.new(color.green,65) : color.new(color.orange,70)
        f_cell(row_offset, 3, pressure_summary, pressure_summary_color, color.black, text.align_center)
        //table.merge_cells(t, 1, row_offset, 3, row_offset)
        row_offset += 1

    //table.merge_cells(t, 1, row_offset, 3, row_offset)
    row_offset += 1

    if bullish_divergence or price_lower_low
        f_cell(row_offset, 0, "âš¡ PhÃ¢n ká»³", color.new(color.purple,75), color.black, text.align_left)
        string div_status = bullish_divergence ? "TÃCH Cá»°C - CÆ¡ há»™i mua" : "â³ Äang theo dÃµi..."
        color div_color = bullish_divergence ? color.new(color.green,55) : color.new(color.orange,75)
        f_cell(row_offset, 1, div_status, div_color, color.black, text.align_center)
        table.merge_cells(t, 1, row_offset, 3, row_offset)
        row_offset += 1


    row_offset

f_get_risk_color(float pct) =>
    pct > 70 ? color.red : pct > 40 ? color.orange : color.green

// Display risk layers
f_display_risk_layers(int offset) =>
    int row_offset = offset
    f_hdr(row_offset, "CÃC Lá»šP Rá»¦I RO")
    row_offset += 1
    float l1_pct = layer1_score / 3.5 * 100.0
    l1_color = f_get_risk_color(l1_pct)

    f_cell(row_offset, 0, "L1: Funding", color.new(color.blue,80), color.black, text.align_left)
    f_cell(row_offset, 1, f_fmt(layer1_score,1), l1_color, color.black, text.align_center)
    f_cell(row_offset, 2, "/3.5", color.new(color.gray,80), color.silver, text.align_left)
    f_cell(row_offset, 3, str.tostring(l1_pct), l1_color, color.white, text.align_left)
    row_offset += 1

    float l2_pct = layer2_score / 6.5 * 100.0
    l2_color = f_get_risk_color(l2_pct)
    f_cell(row_offset, 0, "L2: Cycle", color.new(color.blue,80), color.black, text.align_left)
    f_cell(row_offset, 1, f_fmt(layer2_score,1), l2_color, color.black, text.align_center)
    f_cell(row_offset, 2, "/6.5", color.new(color.gray,80), color.silver, text.align_left)
    f_cell(row_offset, 3, str.tostring(l2_pct), l2_color, color.white, text.align_left)
    row_offset += 1

    float l3_pct = layer3_score / 7.0 * 100.0
    l3_color = f_get_risk_color(l3_pct)
    f_cell(row_offset, 0, "L3: External", color.new(color.blue,80), color.black, text.align_left)
    f_cell(row_offset, 1, f_fmt(layer3_score,1), l3_color, color.black, text.align_center)
    f_cell(row_offset, 2, "/7.0", color.new(color.gray,80), color.silver, text.align_left)
    f_cell(row_offset, 3, str.tostring(l3_pct), l3_color, color.white, text.align_left)
    row_offset += 1
    row_offset

// Display transition matrix
f_display_transition_matrix(int offset) =>
    int row_offset = offset
    string matrix_title = show_full_transition_matrix ? "TRANSITION MATRIX (Full 5x5)" : "TRANSITION MATRIX (Bucket Shifts)"
    f_hdr(row_offset, matrix_title)
    row_offset += 1

    // Calculate total transitions from each bucket
    int[] total_from = array.new_int(5, 0)
    for from = 0 to 4
        int total = 0
        for ito = 0 to 4
            int count = array.get(transition_matrix, from * 5 + ito)
            total += count
        array.set(total_from, from, total)

    if show_full_transition_matrix
        // FULL 5x5 MATRIX DISPLAY
        // Header row: TO buckets
        f_cell(row_offset, 0, "FROMâ†’TO", color.new(color.navy,50), color.black, text.align_center)
        f_cell(row_offset, 1, "B0", color.new(color.navy,50), color.black, text.align_center)
        f_cell(row_offset, 2, "B1", color.new(color.navy,50), color.black, text.align_center)
        f_cell(row_offset, 3, "B2", color.new(color.navy,50), color.black, text.align_center)
        row_offset += 1

        // Note: Due to 4-column limit, show first 3 buckets
        for from_b = 0 to 4
            f_cell(row_offset, 0, "B" + str.tostring(from_b), color.new(color.blue,85), color.black, text.align_center)

            for to_b = 0 to 2
                int count = array.get(transition_matrix, from_b * 5 + to_b)

                // Calculate probability
                int from_total = array.get(total_from, from_b)
                float prob = from_total > 0 ? (count / float(from_total)) * 100.0 : 0.0

                // Color based on probability
                color cell_bg = count == 0 ? color.new(color.gray,90) :
                               prob > 50 ? color.new(color.green,75) :
                               prob > 25 ? color.new(color.orange,80) : color.new(color.red,85)

                string cell_text = count > 0 ? str.tostring(count) + "\n" + f_fmt(prob,0) + "%" : "-"
                f_cell(row_offset, to_b + 1, cell_text, cell_bg, color.black, text.align_center)

            row_offset += 1

        row_offset += 1
        f_cell(row_offset, 0, "ðŸ“ Note:", color.new(color.blue,85), color.black, text.align_left)
        f_cell(row_offset, 1, "Showing B0â†’B2 (Table limit 4 cols)", color.new(color.black,10), color.silver, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)
        row_offset += 1
    else
        // SIMPLIFIED 3x3 MATRIX (Original)
        f_cell(row_offset, 0, "FROMâ†’TO", color.new(color.navy,50), color.black, text.align_center)
        f_cell(row_offset, 1, "B0", color.new(color.navy,50), color.black, text.align_center)
        f_cell(row_offset, 2, "B1", color.new(color.navy,50), color.black, text.align_center)
        f_cell(row_offset, 3, "B2-4", color.new(color.navy,50), color.black, text.align_center)
        row_offset += 1

        // Display simplified 3x3 matrix (B0, B1, B2-4)
        string[] bucket_labels = array.from("B0", "B1", "B2-4")

        for from_group = 0 to 2
            // Highlight current bucket with icon
            bool is_current = (current_bucket == 0 and from_group == 0) or
                             (current_bucket == 1 and from_group == 1) or
                             (current_bucket >= 2 and from_group == 2)
            string label_text = is_current ? "â–¶ " + array.get(bucket_labels, from_group) : array.get(bucket_labels, from_group)
            color label_bg = is_current ? color.new(color.yellow,60) : color.new(color.blue,85)
            f_cell(row_offset, 0, label_text, label_bg, color.black, text.align_center)

            for to_group = 0 to 2
                int count = 0

                // Aggregate counts for groups
                if from_group == 0  // B0
                    if to_group == 0  // to B0
                        count := array.get(transition_matrix, 0 * 5 + 0)
                    else if to_group == 1  // to B1
                        count := array.get(transition_matrix, 0 * 5 + 1)
                    else  // to B2-4
                        count := array.get(transition_matrix, 0 * 5 + 2) + array.get(transition_matrix, 0 * 5 + 3) + array.get(transition_matrix, 0 * 5 + 4)
                else if from_group == 1  // B1
                    if to_group == 0  // to B0
                        count := array.get(transition_matrix, 1 * 5 + 0)
                    else if to_group == 1  // to B1
                        count := array.get(transition_matrix, 1 * 5 + 1)
                    else  // to B2-4
                        count := array.get(transition_matrix, 1 * 5 + 2) + array.get(transition_matrix, 1 * 5 + 3) + array.get(transition_matrix, 1 * 5 + 4)
                else  // B2-4
                    if to_group == 0  // to B0
                        count := array.get(transition_matrix, 2 * 5 + 0) + array.get(transition_matrix, 3 * 5 + 0) + array.get(transition_matrix, 4 * 5 + 0)
                    else if to_group == 1  // to B1
                        count := array.get(transition_matrix, 2 * 5 + 1) + array.get(transition_matrix, 3 * 5 + 1) + array.get(transition_matrix, 4 * 5 + 1)
                    else  // to B2-4
                        count := array.get(transition_matrix, 2 * 5 + 2) + array.get(transition_matrix, 2 * 5 + 3) + array.get(transition_matrix, 2 * 5 + 4) + array.get(transition_matrix, 3 * 5 + 2) + array.get(transition_matrix, 3 * 5 + 3) + array.get(transition_matrix, 3 * 5 + 4) + array.get(transition_matrix, 4 * 5 + 2) + array.get(transition_matrix, 4 * 5 + 3) + array.get(transition_matrix, 4 * 5 + 4)

                // Display count with color based on magnitude
                color cell_bg = count == 0 ? color.new(color.gray,90) : count > 10 ? color.new(color.red,80) : count > 5 ? color.new(color.orange,85) : color.new(color.green,85)
                string count_text = count > 0 ? str.tostring(count) : "-"
                f_cell(row_offset, to_group + 1, count_text, cell_bg, color.black, text.align_center)

            row_offset += 1

    // Interpretation (common for both matrix types)
    row_offset += 1
    f_cell(row_offset, 0, "ðŸ’¡ Giáº£i thÃ­ch:", color.new(color.purple,75), color.black, text.align_left)

    // Calculate stability (diagonal sum / total)
    int diagonal_sum = array.get(transition_matrix, 0) + array.get(transition_matrix, 6) + array.get(transition_matrix, 12) + array.get(transition_matrix, 18) + array.get(transition_matrix, 24)
    int total_transitions = 0
    for i = 0 to 24
        total_transitions += array.get(transition_matrix, i)

    float stability_pct = total_transitions > 0 ? (diagonal_sum / float(total_transitions)) * 100.0 : na

    string interp = ""
    if total_transitions < 10
        interp := "âš  ChÆ°a Ä‘á»§ dá»¯ liá»‡u transitions (N=" + str.tostring(total_transitions) + ")"
    else if not na(stability_pct)
        if stability_pct > 70
            interp := "âœ… á»”n Ä‘á»‹nh cao (" + f_fmt(stability_pct,1) + "%) - Ãt chuyá»ƒn bucket"
        else if stability_pct > 50
            interp := "ðŸŸ¡ Biáº¿n Ä‘á»™ng vá»«a (" + f_fmt(stability_pct,1) + "%) - Thá»‹ trÆ°á»ng dao Ä‘á»™ng"
        else
            interp := "ðŸ”´ Biáº¿n Ä‘á»™ng cao (" + f_fmt(stability_pct,1) + "%) - Rá»§i ro thay Ä‘á»•i nhanh"
    else
        interp := "ChÆ°a cÃ³ dá»¯ liá»‡u"

    f_cell(row_offset, 1, interp, color.new(color.black,10), color.white, text.align_left)
    table.merge_cells(t, 1, row_offset, 3, row_offset)
    row_offset += 1

    // BUCKET DURATION STATISTICS
    row_offset += 1
    f_hdr(row_offset, "BUCKET DURATION (Avg bars)")
    row_offset += 1

    f_cell(row_offset, 0, "Bucket", color.new(color.navy,50), color.white, text.align_center)
    f_cell(row_offset, 1, "Avg Duration", color.new(color.navy,50), color.white, text.align_center)
    f_cell(row_offset, 2, "Visits", color.new(color.navy,50), color.white, text.align_center)
    f_cell(row_offset, 3, "Status", color.new(color.navy,50), color.white, text.align_center)
    row_offset += 1

    // Display duration for key buckets (B0, B1, B2-4 aggregated)
    string[] dur_labels = array.from("B0 (Low)", "B1 (Mod)", "B2-4 (High)")

    for bucket_group = 0 to 2
        float avg_duration = 0.0
        int total_visits = 0

        if bucket_group == 0
            avg_duration := array.get(bucket_durations, 0)
            total_visits := array.get(bucket_visit_count, 0)
        else if bucket_group == 1
            avg_duration := array.get(bucket_durations, 1)
            total_visits := array.get(bucket_visit_count, 1)
        else
            // Aggregate B2-B4
            float sum_dur = array.get(bucket_durations, 2) * array.get(bucket_visit_count, 2) + array.get(bucket_durations, 3) * array.get(bucket_visit_count, 3) + array.get(bucket_durations, 4) * array.get(bucket_visit_count, 4)
            total_visits := array.get(bucket_visit_count, 2) + array.get(bucket_visit_count, 3) + array.get(bucket_visit_count, 4)
            avg_duration := total_visits > 0 ? sum_dur / total_visits : 0.0

        f_cell(row_offset, 0, array.get(dur_labels, bucket_group), color.new(color.blue,85), color.white, text.align_left)

        string dur_text = total_visits > 0 ? f_fmt(avg_duration,1) + " bars" : "N/A"
        color dur_color = avg_duration > 50 ? color.new(color.green,75) : avg_duration > 20 ? color.new(color.orange,80) : total_visits > 0 ? color.new(color.red,80) : color.new(color.gray,85)
        f_cell(row_offset, 1, dur_text, dur_color, color.white, text.align_center)

        f_cell(row_offset, 2, total_visits > 0 ? str.tostring(total_visits) : "-", color.new(color.black,10), color.white, text.align_center)

        string status_text = avg_duration > 50 ? "Stable" : avg_duration > 20 ? "Moderate" : total_visits > 0 ? "Volatile" : "-"
        f_cell(row_offset, 3, status_text, dur_color, color.white, text.align_center)
        row_offset += 1

    // TRANSITION PROBABILITIES (if enough data)
    if total_transitions >= 20
        row_offset += 1
        f_hdr(row_offset, "TRANSITION PROBABILITIES")
        row_offset += 1

        f_cell(row_offset, 0, "ðŸ’¡ Insight:", color.new(color.purple,75), color.white, text.align_left)

        // Calculate key transition probabilities
        // B0 -> B1 (improvement from low risk)
        int b0_to_b1 = array.get(transition_matrix, 0 * 5 + 1)
        int b0_total = 0
        for i = 0 to 4
            b0_total += array.get(transition_matrix, 0 * 5 + i)
        float prob_b0_to_b1 = b0_total > 0 ? (b0_to_b1 / float(b0_total)) * 100.0 : na

        // B2-4 -> B0-1 (improvement from high risk)
        int high_to_low = array.get(transition_matrix, 2 * 5 + 0) + array.get(transition_matrix, 2 * 5 + 1) + array.get(transition_matrix, 3 * 5 + 0) + array.get(transition_matrix, 3 * 5 + 1) + array.get(transition_matrix, 4 * 5 + 0) + array.get(transition_matrix, 4 * 5 + 1)
        int high_total = 0
        for from_b = 2 to 4
            for to_b = 0 to 4
                high_total += array.get(transition_matrix, from_b * 5 + to_b)
        float prob_high_to_low = high_total > 0 ? (high_to_low / float(high_total)) * 100.0 : na

        string prob_insight = ""
        if not na(prob_b0_to_b1) and prob_b0_to_b1 > 60
            prob_insight := "ðŸŸ¢ Low risk (B0) cÃ³ " + f_fmt(prob_b0_to_b1,0) + "% chuyá»ƒn sang B1 - Xu hÆ°á»›ng tÄƒng risk tá»± nhiÃªn"
        else if not na(prob_high_to_low) and prob_high_to_low > 50
            prob_insight := "âœ… High risk (B2-4) cÃ³ " + f_fmt(prob_high_to_low,0) + "% quay vá» B0-1 - Há»“i phá»¥c tá»‘t"
        else if not na(prob_high_to_low) and prob_high_to_low < 30
            prob_insight := "âš ï¸ High risk (B2-4) khÃ³ thoÃ¡t (" + f_fmt(prob_high_to_low,0) + "% vá» B0-1) - Cáº§n thá»i gian"
        else
            prob_insight := "Transition patterns: " + str.tostring(total_transitions) + " shifts tracked"

        f_cell(row_offset, 1, prob_insight, color.new(color.black,10), color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)

    row_offset + 1




// Display panel-specific details (refactored from giant if statement)
f_display_panel_specific(int offset) =>
    int row_offset = offset


    // PANEL-SPECIFIC DETAILS

    f_hdr(row_offset, "CHI TIáº¾T: " + panelOption)
    row_offset += 1

    // Column headers with better styling
    f_cell(row_offset, 0, "Chá»‰ tiÃªu", color.new(color.navy,50), color.white, text.align_left)
    f_cell(row_offset, 1, "GiÃ¡ trá»‹", color.new(color.navy,50), color.white, text.align_center)
    f_cell(row_offset, 2, "PCTL", color.new(color.navy,50), color.white, text.align_center)
    f_cell(row_offset, 3, "Ã nghÄ©a", color.new(color.navy,50), color.white, text.align_left)
    row_offset += 1

    row_offset


// Display panel 1 details
f_display_panel1(int offset) =>
    int row_offset = offset
    f_row(row_offset, "Lam phat", f_fmt(pi_m,2)+"%", f_pctl_text(p_pi,true), p_pi, true, "ThÃ¡ng nÃ y")
    f_row(row_offset+1, "Du bao", f_fmt(pi_e_m,2)+"%", f_pctl_text(p_epi,true), p_epi, true, "Dá»± bÃ¡o thÃ¡ng sau")
    f_row(row_offset+2, "So voi trend", f_fmt(pi_gap_m,2), f_pctl_text(p_gap,true), p_gap, true, "DÆ°Æ¡ng(+)=nÃ³ng hÆ¡n")
    f_row(row_offset+3, "Dong luc", f_fmt(dpi_m,2), f_pctl_text(p_dpi,true), p_dpi, true, "ThÃ¡ng nÃ y vs thÃ¡ng trÆ°á»›c")
    f_row(row_offset+4, "Lech du bao", f_fmt(surprise_m,2), f_pctl_text(p_sur,true), p_sur, true, "DÆ°Æ¡ng(+)=cao hÆ¡n dá»± Ä‘oÃ¡n")
    f_row(row_offset+5, "Ap luc lai suat", f_fmt(tight_idx,2), f_pctl_text(p_tight,true), p_tight, true, "Ãp lá»±c lÃ£i suáº¥t")
    row_offset += 6
    string infl_trend = pi_m > pi_e_m ? "ðŸ“ˆ Cao hÆ¡n dá»± bÃ¡o: Cáº£nh bÃ¡o tÄƒng lÃ£i suáº¥t " : pi_m < pi_e_m - 0.5 ? "ðŸ“‰ Tháº¥p hÆ¡n dá»± bÃ¡o: Ká»³ vá»ng ná»›i lá»ng" : "âž¡ ÄÃºng dá»± bÃ¡o"
    f_cell(row_offset, 0, "Xu hÆ°á»›ng:", color.new(color.blue,20), color.white, text.align_left)
    f_cell(row_offset, 1, infl_trend, color.new(color.black,10), color.white, text.align_left)
    table.merge_cells(t, 1, row_offset, 3, row_offset)
    row_offset += 1
    f_cell(row_offset, 0, "Tráº¡ng thÃ¡i:", color.new(color.blue,20), color.white, text.align_left)
    color state_color = cond_hot ? color.new(color.red,60) : cond_cool ? color.new(color.green,60) : color.new(color.orange,60)
    f_cell(row_offset, 1, infl_state, state_color, color.white, text.align_left)
    table.merge_cells(t, 1, row_offset, 3, row_offset)
    row_offset += 1
    f_cell(row_offset, 0, "Äá»™ chÃ­nh xÃ¡c dá»± bÃ¡o:", color.new(color.blue,20), color.white, text.align_left)
    string infl_eval = "MAE24=" + (na(mae24_m) ? "-" : f_fmt(mae24_m,2)) + " | RMSE=" + (na(rmse24_m) ? "-" : f_fmt(rmse24_m,2))
    f_cell(row_offset, 1, infl_eval, color.new(color.black,10), color.white, text.align_left)
    table.merge_cells(t, 1, row_offset, 3, row_offset)
    row_offset + 1

// Display panel 2 details
f_display_panel2(int offset) =>
    int row_offset = offset
    f_row(row_offset, "Lai suat dieu hanh", f_fmt(i_policy_m,2)+"%", f_pctl_text(p_ipol,true), p_ipol, true, "Cao=tháº¯t hÆ¡n")
    f_row(row_offset+1, "Lien ngan hang", f_fmt(i_ib_m,2)+"%", f_pctl_text(p_iib,true), p_iib, true, "Cao=thiáº¿u thanh khoáº£n")
    f_row(row_offset+2, "Lai thuc", f_fmt(r_real_m,2)+"%", f_pctl_text(p_rreal,true), p_rreal, true, "Policy - Dá»± bÃ¡o Inflation")
    f_row(row_offset+3, "Ap luc lai suat", f_fmt(tight_idx,2), f_pctl_text(p_tight,true), p_tight, true, "Tá»•ng há»£p (cao=tháº¯t)")
    f_row(row_offset+4, "Policy gap", f_fmt(policy_gap,2), f_pctl_text(p_polgap,true), p_polgap, true, "DÆ°Æ¡ng=tháº¯t quÃ¡ má»©c")
    row_offset += 5
    string rate_policy = stress_high ? "âš  THáº®T CHáº¶T" : tight_idx < -1 ? "âœ… Dá»„ DÃƒNG" : "âž¡ TRUNG TÃNH"
    f_cell(row_offset, 0, "ChÃ­nh sÃ¡ch:", color.new(color.blue,20), color.white, text.align_left)
    color rate_color = stress_high ? color.new(color.red,60) : tight_idx < -1 ? color.new(color.green,60) : color.new(color.black,10)
    f_cell(row_offset, 1, rate_policy, rate_color, color.white, text.align_left)
    table.merge_cells(t, 1, row_offset, 3, row_offset)
    row_offset + 1

// Display panel 3 details
f_display_panel3(int offset) =>
    int row_offset = offset
    f_row(row_offset, "GDP", f_fmt(gdp_q,2)+"%", f_pctl_text(p_gdp,true), p_gdp, false, "Cao=tá»‘t")
    f_row(row_offset+1, "So voi trend", f_fmt(gdp_gap_q,2), f_pctl_text(p_gdpgap,true), p_gdpgap, false, "DÆ°Æ¡ng(+)=máº¡nh")
    f_row(row_offset+2, "Sá»©c máº¡nh", f_fmt(grow_idx,2), f_pctl_text(p_grow,true), p_grow, false, "Chá»‰ sá»‘ (cao=tá»‘t)")
    row_offset += 3
    string growth_status = growth_low ? "âš  Yáº¾U - Rá»§i ro suy thoÃ¡i" : gdp_gap_q > 1 ? "âœ… Máº NH - TrÃªn tiá»m nÄƒng" : "âž¡ á»”N Äá»ŠNH"
    f_cell(row_offset, 0, "TÄƒng trÆ°á»Ÿng:", color.new(color.blue,20), color.white, text.align_left)
    color growth_color = growth_low ? color.new(color.red,60) : gdp_gap_q > 1 ? color.new(color.green,60) : color.new(color.black,10)
    f_cell(row_offset, 1, growth_status, growth_color, color.white, text.align_left)
    table.merge_cells(t, 1, row_offset, 3, row_offset)
    row_offset + 1


// Display scenario analysis
f_display_scenario(int offset) =>
    int row_offset = offset
    f_hdr(row_offset, "Ká»ŠCH Báº¢N VÄ¨ MÃ”")
    row_offset += 1

    color scenario_bg = scenario_severity == 4 ? color.new(color.green,50) : scenario_severity == 3 ? color.new(color.red,60) : scenario_severity == 2 ? color.new(color.orange,65) : scenario_severity == 1 ? color.new(color.blue,70) : color.new(color.gray,75)
    string severity_icon = scenario_severity == 4 ? "ðŸŒŸ " : scenario_severity == 3 ? "ðŸš¨ " : scenario_severity == 2 ? "âš ï¸ " : scenario_severity == 1 ? "â„¹ï¸ " : "âž– "
    f_cell(row_offset, 0, "TÃ¬nh huá»‘ng:", color.new(color.blue,80), color.black, text.align_left)
    f_cell(row_offset, 1, severity_icon + scenario_name, scenario_bg, color.black, text.align_left)
    table.merge_cells(t, 1, row_offset, 3, row_offset)
    row_offset += 1

    string scenario_detail = ""
    if scenario_fx_crisis
        scenario_detail := "ðŸš¨ KHáº¨N Cáº¤P: Tá»· giÃ¡ biáº¿n Ä‘á»™ng máº¡nh + Ãp lá»±c FX + Fed gap cao\nâ†’ Giáº£m exposure, chá» á»•n Ä‘á»‹nh"
    else if scenario_liquidity_crisis
        scenario_detail := "âš  CÄƒng tháº³ng thanh khoáº£n + Äáº£o ngÆ°á»£c YC + Ãp lá»±c quá»‘c táº¿\nâ†’ Defensive, tÄƒng cash/bonds"
    else if scenario_stagflation
        scenario_detail := "âš  Láº¡m phÃ¡t cao + GDP yáº¿u + LÃ£i suáº¥t tháº¯t â†’ Ráº¥t khÃ³ xá»­ lÃ½\nâ†’ Commodities, trÃ¡nh growth stocks"
    else if scenario_credit_bubble
        scenario_detail := "âš  TÃ­n dá»¥ng nÃ³ng + Láº¡m phÃ¡t + Äá»‹nh giÃ¡ cao â†’ Rá»§i ro sá»¥p Ä‘á»•\nâ†’ Giáº£m leverage, chá»‘t lá»i"
    else if scenario_bear_market
        scenario_detail := "ðŸ“‰ Risk cao + VÄ© mÃ´ xáº¥u Ä‘i + Äá»‹nh giÃ¡ khÃ´ng háº¥p dáº«n\nâ†’ Chá» signal cáº£i thiá»‡n"
    else if scenario_bull_market
        scenario_detail := "âœ… GiÃ¡ ráº» + PhÃ¢n ká»³ tÃ­ch cá»±c + VÄ© mÃ´ cáº£i thiá»‡n â†’ MUA Dáº¦N\nâ†’ TÄƒng exposure, Æ°u tiÃªn quality"
    else if scenario_inflation_surge
        scenario_detail := "âš  Láº¡m phÃ¡t + Chi phÃ­ tÄƒng + FX/Oil báº¥t á»•n\nâ†’ Real assets, defensive sectors"
    else if scenario_growth_slowdown
        scenario_detail := "ðŸ“‰ GDP yáº¿u + Chi phÃ­ cao + Spread thu háº¹p\nâ†’ Quality stocks, bonds"
    else if scenario_soft_landing
        scenario_detail := "âœ… VÄ© mÃ´ á»•n Ä‘á»‹nh vÃ  cáº£i thiá»‡n dáº§n\nâ†’ Balanced approach, theo dÃµi"
    else
        scenario_detail := "KhÃ´ng cÃ³ tÃ­n hiá»‡u Ä‘áº·c biá»‡t, tiáº¿p tá»¥c theo dÃµi"

    f_cell(row_offset, 0, "Chi tiáº¿t:", color.new(color.black,10), color.yellow, text.align_left)
    f_cell(row_offset, 1, scenario_detail, color.new(color.black,10), color.white, text.align_left)
    table.merge_cells(t, 1, row_offset, 3, row_offset)
    row_offset += 1

    // BUCKET-SPECIFIC GUIDANCE
    string bucket_guidance = ""
    if current_bucket == 0
        bucket_guidance := "ðŸ’¡ B0: Risk ráº¥t tháº¥p â†’ TÄƒng tá»· trá»ng equity (60-70%), Æ°u tiÃªn cyclical & smallcap"
    else if current_bucket == 1
        bucket_guidance := "ðŸ’¡ B1: Risk tháº¥p â†’ Balanced (50-60% equity), midcap cÃ³ cÆ¡ há»™i"
    else if current_bucket == 2
        bucket_guidance := "ðŸ’¡ B2: Risk trung bÃ¬nh â†’ CÃ¢n Ä‘á»‘i (40-50% equity), quality focus"
    else if current_bucket == 3
        bucket_guidance := "ðŸ’¡ B3: Risk cao â†’ Defensive (25-35% equity), large caps/bonds"
    else
        bucket_guidance := "ðŸ’¡ B4: Risk ráº¥t cao â†’ Báº£o toÃ n (15-25% equity), cash/bonds/gold"

    f_cell(row_offset, 0, "Guidance:", color.new(color.purple,70), color.black, text.align_left)
    f_cell(row_offset, 1, bucket_guidance, color.new(color.purple,85), color.black, text.align_left)
    table.merge_cells(t, 1, row_offset, 3, row_offset)
    row_offset += 1
    row_offset


// Display performance metrics
f_display_performance(int offset) =>
    int row_offset = offset
    f_hdr(row_offset, "HIá»†U SUáº¤T Dá»° BÃO")
    row_offset += 1

    f_cell(row_offset, 0, "Äá»™ chÃ­nh xÃ¡c", color.new(color.blue,85), color.black, text.align_left)
    string accuracy_text = na(perf_accuracy) ? "--" : f_fmt(perf_accuracy,1) + "%"
    color accuracy_color = na(perf_accuracy) ? color.new(color.gray,70) : perf_accuracy > 85 ? color.new(color.green,65) : perf_accuracy > 75 ? color.new(color.orange,70) : color.new(color.red,70)
    string acc_icon = na(perf_accuracy) ? "" : perf_accuracy > 85 ? "â­ " : perf_accuracy > 75 ? "âœ“ " : "âš ï¸ "
    f_cell(row_offset, 1, acc_icon + accuracy_text, accuracy_color, color.black, text.align_center)
    f_cell(row_offset, 2, "MAE:", color.new(color.gray,85), color.silver, text.align_right)
    f_cell(row_offset, 3, na(mae24_m) ? "--" : f_fmt(mae24_m,2), color.new(color.black,0), color.white, text.align_center)
    row_offset += 1

    f_cell(row_offset, 0, "RMSE", color.new(color.blue,85), color.black, text.align_left)
    string rmse_val = na(rmse24_m) ? "--" : f_fmt(rmse24_m,2)
    color rmse_color = na(rmse24_m) ? color.new(color.gray,70) : rmse24_m < 0.30 ? color.new(color.green,70) : color.new(color.orange,70)
    f_cell(row_offset, 1, rmse_val, rmse_color, color.black, text.align_center)
    f_cell(row_offset, 2, "ðŸ”„ Churn", color.new(color.blue,85), color.black, text.align_left)
    string churn_val = na(churn12) ? "--" : str.tostring(int(churn12))
    color churn_color = na(churn12) ? color.new(color.gray,70) : churn12 <= 2 ? color.new(color.green,70) : churn12 <= 4 ? color.new(color.orange,70) : color.new(color.red,70)
    f_cell(row_offset, 3, churn_val, churn_color, color.black, text.align_center)
    row_offset += 1

    f_cell(row_offset, 0, "âœ… Tá»•ng quÃ¡t", color.new(color.purple,75), color.black, text.align_left)
    string eval_icon = eval_vi == "Tin hieu: on dinh" ? "ðŸŸ¢ " : "ðŸŸ¡ "
    color eval_color = eval_vi == "Tin hieu: on dinh" ? color.new(color.green,65) : color.new(color.orange,70)
    f_cell(row_offset, 1, eval_icon + eval_vi, eval_color, color.black, text.align_center)
    table.merge_cells(t, 1, row_offset, 3, row_offset)
    row_offset + 1


if barstate.islast
    // Display sections using helper functions
    row_offset = f_display_header(1)
    row_offset := f_display_signals(row_offset)
    row_offset := f_display_macro_indicators(row_offset)
    row_offset := f_display_risk_layers(row_offset)
    row_offset := f_display_scenario(row_offset)
    row_offset := f_display_performance(row_offset)
    // Panel-specific details header
    row_offset := f_display_panel_specific(row_offset)

    // Panel-specific content
    if panel == 7 and useCredit
        f_row(row_offset, "M2 YoY", f_fmt(m2_yoy_m,2)+"%", f_pctl_text(p_m2,true), p_m2, true, "TÄƒng trÆ°á»Ÿng tÃ­n dá»¥ng")
        f_row(row_offset+1, "M2 vs Trend", f_fmt(m2_gap_m,2), f_pctl_text(p_m2gap,true), p_m2gap, true, "Cao = nÃ³ng")
        f_row(row_offset+2, "Credit Index", f_fmt(credit_idx,2), f_pctl_text(p_credit,true), p_credit, true, "Chá»‰ sá»‘ tá»•ng há»£p")
        row_offset += 3
        string credit_status = credit_high ? "âš  NÃ“NG - Cáº§n tháº¯t cháº·t" : m2_yoy_m > 15 ? "TÄƒng cao" : "á»”n Ä‘á»‹nh"
        f_cell(row_offset, 0, "Tráº¡ng thÃ¡i:", color.new(color.blue,20), color.white, text.align_left)
        f_cell(row_offset, 1, credit_status, credit_high ? color.new(color.red,60) : color.new(color.green,60), color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)
        row_offset += 1
    else if panel == 1
        row_offset := f_display_panel1(row_offset)
    else if panel == 2
        row_offset := f_display_panel2(row_offset)
    else if panel == 3
        row_offset := f_display_panel3(row_offset)
    else if panel == 4 and useYieldCurve
        // BASIC YC ANALYSIS
        f_row(row_offset, "Do doc (10Y-2Y)", f_fmt(yc_slope_m,2)+" bp", f_pctl_text(p_yc,true), p_yc, false, "Ã‚m=Ä‘áº£o ngÆ°á»£c")
        f_row(row_offset+1, "YC (idx)", f_fmt(yc_idx,2), f_pctl_text(p_ycidx,true), p_ycidx, true, "Báº¥t thÆ°á»ng")
        f_row(row_offset+2, "Intl Diff", f_fmt(intl_yield_diff,2)+" bp", f_pctl_text(p_intl,true), p_intl, true,intl_yield_diff < 0.5 ? "Lá»£i suáº¥t VN khÃ´ng cÃ²n háº¥p dáº«n" : "Tháº¥p=xáº¥u")
        f_row(row_offset+3, "L-S Spread", f_fmt(long_short_spread,2)+" bp", f_pctl_text(p_spread,true), p_spread, true, long_short_spread < 0.5 ? "Term premium thu háº¹p â†’ rá»§i ro" : "Tháº¥p=xáº¥u")
        row_offset += 4
        string yc_status = curve_inversion ? "âš  Äáº¢O NGÆ¯á»¢C - Recession risk cao" : yc_slope_m > 1 ? "âœ… BÃŒNH THÆ¯á»œNG Ká»³ vá»ng tÄƒng trÆ°á»Ÿng tá»‘t" : "âž¡ PHáº²NG"
        f_cell(row_offset, 0, "ÄÆ°á»ng cong lÃ£i suáº¥t:", color.new(color.blue,20), color.white, text.align_left)
        color yc_color = curve_inversion ? color.new(color.red,60) : yc_slope_m > 1 ? color.new(color.green,60) : color.new(color.orange,60)
        f_cell(row_offset, 1, yc_status, yc_color, color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)

        // YIELD CURVE LAB (if enabled)
        if use_yc_lab
            row_offset += 2
            f_hdr(row_offset, "YIELD CURVE LAB (Level-Slope-Curve)")
            row_offset += 1

            // YC GRID TABLE - 3 TENORS (2Y/5Y/10Y)
            f_cell(row_offset, 0, "Tenor", color.new(color.navy,50), color.white, text.align_center)
            f_cell(row_offset, 1, "Yield%", color.new(color.navy,50), color.white, text.align_center)
            f_cell(row_offset, 2, "Z-State", color.new(color.navy,50), color.white, text.align_center)
            f_cell(row_offset, 3, "Move", color.new(color.navy,50), color.white, text.align_center)
            row_offset += 1

            // 2Y Row
            float y2_z = use_yc_lab ? f_z(vn02y_d, yc_stats_len, yc_clip_mult) : na
            string y2_state = na(y2_z) ? "-" : y2_z > 1.0 ? "RICH" : y2_z < -1.0 ? "CHEAP" : "FAIR"
            color y2_state_color = y2_state == "CHEAP" ? color.new(color.green,70) : y2_state == "RICH" ? color.new(color.red,70) : color.new(color.gray,80)
            float y2_chg = not na(vn02y_d) and not na(vn02y_d[60]) ? vn02y_d - vn02y_d[60] : na
            string y2_move = na(y2_chg) ? "-" : y2_chg > 0.1 ? "UPâ†‘" : y2_chg < -0.1 ? "DNâ†“" : "FLAT"
            f_cell(row_offset, 0, "VN02Y", color.new(color.black,10), color.white, text.align_left)
            f_cell(row_offset, 1, not na(vn02y_d) ? f_fmt(vn02y_d,2)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
            f_cell(row_offset, 2, y2_state, y2_state_color, color.white, text.align_center)
            f_cell(row_offset, 3, y2_move, color.new(color.black,10), y2_chg > 0.1 ? color.red : y2_chg < -0.1 ? color.green : color.silver, text.align_center)
            row_offset += 1

            // 5Y Row
            float y5_z = use_yc_lab ? f_z(vn05y_d, yc_stats_len, yc_clip_mult) : na
            string y5_state = na(y5_z) ? "-" : y5_z > 1.0 ? "RICH" : y5_z < -1.0 ? "CHEAP" : "FAIR"
            color y5_state_color = y5_state == "CHEAP" ? color.new(color.green,70) : y5_state == "RICH" ? color.new(color.red,70) : color.new(color.gray,80)
            float y5_chg = not na(vn05y_d) and not na(vn05y_d[60]) ? vn05y_d - vn05y_d[60] : na
            string y5_move = na(y5_chg) ? "-" : y5_chg > 0.1 ? "UPâ†‘" : y5_chg < -0.1 ? "DNâ†“" : "FLAT"
            f_cell(row_offset, 0, "VN05Y", color.new(color.black,10), color.white, text.align_left)
            f_cell(row_offset, 1, not na(vn05y_d) ? f_fmt(vn05y_d,2)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
            f_cell(row_offset, 2, y5_state, y5_state_color, color.white, text.align_center)
            f_cell(row_offset, 3, y5_move, color.new(color.black,10), y5_chg > 0.1 ? color.red : y5_chg < -0.1 ? color.green : color.silver, text.align_center)
            row_offset += 1

            // 10Y Row
            float y10_z = use_yc_lab ? f_z(vn10y_d, yc_stats_len, yc_clip_mult) : na
            string y10_state = na(y10_z) ? "-" : y10_z > 1.0 ? "RICH" : y10_z < -1.0 ? "CHEAP" : "FAIR"
            color y10_state_color = y10_state == "CHEAP" ? color.new(color.green,70) : y10_state == "RICH" ? color.new(color.red,70) : color.new(color.gray,80)
            float y10_chg = not na(vn10y_d) and not na(vn10y_d[60]) ? vn10y_d - vn10y_d[60] : na
            string y10_move = na(y10_chg) ? "-" : y10_chg > 0.1 ? "UPâ†‘" : y10_chg < -0.1 ? "DNâ†“" : "FLAT"
            f_cell(row_offset, 0, "VN10Y", color.new(color.black,10), color.white, text.align_left)
            f_cell(row_offset, 1, not na(vn10y_d) ? f_fmt(vn10y_d,2)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
            f_cell(row_offset, 2, y10_state, y10_state_color, color.white, text.align_center)
            f_cell(row_offset, 3, y10_move, color.new(color.black,10), y10_chg > 0.1 ? color.red : y10_chg < -0.1 ? color.green : color.silver, text.align_center)
            row_offset += 1

            // LEVEL-SLOPE-CURVE FACTORS
            row_offset += 1
            f_cell(row_offset, 0, "Factors", color.new(color.purple,70), color.white, text.align_left)
            table.merge_cells(t, 0, row_offset, 3, row_offset)
            row_offset += 1

            f_cell(row_offset, 0, "Level", color.new(color.blue,85), color.white, text.align_left)
            f_cell(row_offset, 1, not na(yc_level) ? f_fmt(yc_level,2)+"%" : "NA", color.new(color.black,10), color.white, text.align_center)
            f_cell(row_offset, 2, "Slope", color.new(color.blue,85), color.white, text.align_left)
            f_cell(row_offset, 3, not na(yc_slope) ? f_fmt(yc_slope,2)+"bp" : "NA", color.new(color.black,10), color.white, text.align_center)
            row_offset += 1

            f_cell(row_offset, 0, "Curvature", color.new(color.blue,85), color.white, text.align_left)
            f_cell(row_offset, 1, not na(yc_curve) ? f_fmt(yc_curve,3)+"bp" : "NA", color.new(color.black,10), color.white, text.align_center)
            f_cell(row_offset, 2, "Regime", color.new(color.blue,85), color.white, text.align_left)
            color regime_color = yc_regime_code == "YC4" ? color.new(color.red,60) :
                                 yc_regime_code == "YC1" ? color.new(color.green,60) : color.new(color.orange,60)
            f_cell(row_offset, 3, yc_regime_code, regime_color, color.white, text.align_center)
            row_offset += 1

            // QUALITY & STRESS
            row_offset += 1
            f_cell(row_offset, 0, "Quality & Stress", color.new(color.purple,70), color.white, text.align_left)
            table.merge_cells(t, 0, row_offset, 3, row_offset)
            row_offset += 1

            f_cell(row_offset, 0, "Quality", color.new(color.blue,85), color.white, text.align_left)
            color qual_color = yc_quality_label == "HIGHQ" ? color.new(color.green,60) :
                              yc_quality_label == "LOWQ" ? color.new(color.red,60) : color.new(color.orange,60)
            string qual_text = not na(yc_quality) ? f_fmt(yc_quality,1)+"% ("+yc_quality_label+")" : "NA"
            f_cell(row_offset, 1, qual_text, qual_color, color.white, text.align_center)
            table.merge_cells(t, 1, row_offset, 3, row_offset)
            row_offset += 1

            f_cell(row_offset, 0, "Distortion", color.new(color.blue,85), color.white, text.align_left)
            f_cell(row_offset, 1, not na(yc_distortion) ? f_fmt(yc_distortion,3) : "NA", color.new(color.black,10), color.white, text.align_center)
            f_cell(row_offset, 2, "Stress(adj)", color.new(color.blue,85), color.white, text.align_left)
            color stress_color = not na(yc_stress_adj) and yc_stress_adj >= 70 ? color.new(color.red,60) :not na(yc_stress_adj) and yc_stress_adj <= 40 ? color.new(color.green,60) : color.new(color.black,10)
            f_cell(row_offset, 3, not na(yc_stress_adj) ? f_fmt(yc_stress_adj,1)+"%" : "NA", stress_color, color.white, text.align_center)
            row_offset += 1

            // YC RESEARCH VS VNINDEX (if enabled)
            if use_yc_research
                row_offset += 1
                f_hdr(row_offset, "RESEARCH: YC Stress â†’ VNINDEX")
                row_offset += 1

                // Status & EffN
                f_cell(row_offset, 0, "Status", color.new(color.blue,85), color.white, text.align_left)
                color status_color = yc_research_status == "READY" ? color.new(color.green,70) : color.new(color.orange,70)
                string status_text = yc_research_status + " (N=" + (na(yc_eff_n) ? "-" : str.tostring(int(yc_eff_n))) + "/" + str.tostring(yc_research_len) + ")"
                f_cell(row_offset, 1, status_text, status_color, color.white, text.align_center)
                table.merge_cells(t, 1, row_offset, 3, row_offset)
                row_offset += 1

                if yc_research_status == "READY"
                    // Correlation with 3 lags
                    f_cell(row_offset, 0, "Corr (lag)", color.new(color.navy,50), color.white, text.align_left)
                    f_cell(row_offset, 1, "L" + str.tostring(yc_lag1), color.new(color.navy,50), color.white, text.align_center)
                    f_cell(row_offset, 2, "L" + str.tostring(yc_lag2), color.new(color.navy,50), color.white, text.align_center)
                    f_cell(row_offset, 3, "L" + str.tostring(yc_lag3), color.new(color.navy,50), color.white, text.align_center)
                    row_offset += 1

                    // Correlation values with color coding
                    f_cell(row_offset, 0, "Correlation", color.new(color.blue,85), color.white, text.align_left)

                    // Lag 1
                    color corr1_bg = na(yc_vnx_corr_lag1) ? color.new(color.gray,85) :
                                     math.abs(yc_vnx_corr_lag1) > 0.5 ? color.new(color.red,70) :
                                     math.abs(yc_vnx_corr_lag1) > 0.3 ? color.new(color.orange,75) : color.new(color.gray,85)
                    string corr1_icon = not na(yc_best_lag) and yc_best_lag == yc_lag1 ? "â­" : ""
                    f_cell(row_offset, 1, corr1_icon + (na(yc_vnx_corr_lag1) ? "-" : f_fmt(yc_vnx_corr_lag1,3)), corr1_bg, color.white, text.align_center)

                    // Lag 2
                    color corr2_bg = na(yc_vnx_corr_lag2) ? color.new(color.gray,85) :
                                     math.abs(yc_vnx_corr_lag2) > 0.5 ? color.new(color.red,70) :
                                     math.abs(yc_vnx_corr_lag2) > 0.3 ? color.new(color.orange,75) : color.new(color.gray,85)
                    string corr2_icon = not na(yc_best_lag) and yc_best_lag == yc_lag2 ? "â­" : ""
                    f_cell(row_offset, 2, corr2_icon + (na(yc_vnx_corr_lag2) ? "-" : f_fmt(yc_vnx_corr_lag2,3)), corr2_bg, color.white, text.align_center)

                    // Lag 3
                    color corr3_bg = na(yc_vnx_corr_lag3) ? color.new(color.gray,85) :
                                     math.abs(yc_vnx_corr_lag3) > 0.5 ? color.new(color.red,70) :
                                     math.abs(yc_vnx_corr_lag3) > 0.3 ? color.new(color.orange,75) : color.new(color.gray,85)
                    string corr3_icon = not na(yc_best_lag) and yc_best_lag == yc_lag3 ? "â­" : ""
                    f_cell(row_offset, 3, corr3_icon + (na(yc_vnx_corr_lag3) ? "-" : f_fmt(yc_vnx_corr_lag3,3)), corr3_bg, color.white, text.align_center)
                    row_offset += 1

                    // BestLag & RÂ²
                    f_cell(row_offset, 0, "BestLag", color.new(color.blue,85), color.white, text.align_left)
                    f_cell(row_offset, 1, not na(yc_best_lag) ? "L" + str.tostring(yc_best_lag) : "-", color.new(color.black,10), color.yellow, text.align_center)
                    f_cell(row_offset, 2, "RÂ²", color.new(color.blue,85), color.white, text.align_left)
                    color r2_color = not na(yc_vnx_r2_best) and yc_vnx_r2_best > 0.25 ? color.new(color.green,70) : color.new(color.gray,85)
                    f_cell(row_offset, 3, not na(yc_vnx_r2_best) ? f_fmt(yc_vnx_r2_best,3) : "-", r2_color, color.white, text.align_center)
                    row_offset += 1

                    // Beta & Lag Stability
                    f_cell(row_offset, 0, "Beta", color.new(color.blue,85), color.white, text.align_left)
                    f_cell(row_offset, 1, not na(yc_vnx_beta_best) ? f_fmt(yc_vnx_beta_best,4) : "-", color.new(color.black,10), color.white, text.align_center)
                    f_cell(row_offset, 2, "Lag Stab%", color.new(color.blue,85), color.white, text.align_left)
                    color stab_color = not na(yc_lag_stability) and yc_lag_stability > 60 ? color.new(color.green,70) : color.new(color.orange,75)
                    f_cell(row_offset, 3, not na(yc_lag_stability) ? f_fmt(yc_lag_stability,1)+"%" : "-", stab_color, color.white, text.align_center)
                    row_offset += 1

                    // Interpretation
                    row_offset += 1
                    f_cell(row_offset, 0, "ðŸ’¡ Giáº£i thÃ­ch:", color.new(color.purple,75), color.white, text.align_left)
                    string research_interp = ""
                    if not na(yc_vnx_r2_best) and yc_vnx_r2_best < 0.10
                        research_interp := "TÆ°Æ¡ng quan yáº¿u - Stress Ã­t áº£nh hÆ°á»Ÿng VNINDEX"
                    else if not na(yc_vnx_corr_lag1) and yc_vnx_corr_lag1 < -0.3
                        research_interp := "TÆ°Æ¡ng quan Ã¢m - Stress cao â†’ VNINDEX giáº£m"
                    else if not na(yc_lag_stability) and yc_lag_stability < 50
                        research_interp := "Lag khÃ´ng á»•n Ä‘á»‹nh - Quan há»‡ khÃ´ng Ä‘Ã¡ng tin"
                    else
                        research_interp := "BestLag: L" + (na(yc_best_lag) ? "-" : str.tostring(yc_best_lag)) + " | RÂ²=" + (na(yc_vnx_r2_best) ? "-" : f_fmt(yc_vnx_r2_best,2))
                    f_cell(row_offset, 1, research_interp, color.new(color.black,10), color.white, text.align_left)
                    table.merge_cells(t, 1, row_offset, 3, row_offset)

                    // REGIME-FILTERED RESEARCH (OKQ - Only OK Quality)
                    row_offset += 2
                    f_hdr(row_offset, "ðŸ“Š REGIME FILTER: OKQ (Quality >= " + f_fmt(yc_quality_threshold,0) + ")")
                    row_offset += 1

                    // OKQ Status
                    f_cell(row_offset, 0, "OKQ Status", color.new(color.blue,85), color.white, text.align_left)
                    color okq_status_color = yc_okq_status == "READY" ? color.new(color.green,70) : color.new(color.orange,70)
                    string okq_status_text = yc_okq_status + " (N=" + (na(yc_eff_n_okq) ? "-" : str.tostring(int(yc_eff_n_okq))) + ")"
                    f_cell(row_offset, 1, okq_status_text, okq_status_color, color.white, text.align_center)
                    table.merge_cells(t, 1, row_offset, 3, row_offset)
                    row_offset += 1

                    if yc_okq_status == "READY"
                        // OKQ Correlation & Beta
                        f_cell(row_offset, 0, "Corr (OKQ)", color.new(color.blue,85), color.white, text.align_left)
                        color okq_corr_bg = na(yc_vnx_corr_okq) ? color.new(color.gray,85) :
                                           math.abs(yc_vnx_corr_okq) > 0.5 ? color.new(color.red,70) :
                                           math.abs(yc_vnx_corr_okq) > 0.3 ? color.new(color.orange,75) : color.new(color.gray,85)
                        f_cell(row_offset, 1, na(yc_vnx_corr_okq) ? "-" : f_fmt(yc_vnx_corr_okq,3), okq_corr_bg, color.white, text.align_center)
                        f_cell(row_offset, 2, "Beta (OKQ)", color.new(color.blue,85), color.white, text.align_left)
                        f_cell(row_offset, 3, na(yc_vnx_beta_okq) ? "-" : f_fmt(yc_vnx_beta_okq,4), color.new(color.black,10), color.white, text.align_center)
                        row_offset += 1

                        // Comparison with ALL
                        row_offset += 1
                        f_cell(row_offset, 0, "ðŸ“ˆ So sÃ¡nh:", color.new(color.purple,75), color.white, text.align_left)
                        string okq_compare = ""
                        if not na(yc_vnx_corr_okq) and not na(yc_vnx_corr_lag1)
                            float corr_diff = math.abs(yc_vnx_corr_okq) - math.abs(yc_vnx_corr_lag1)
                            if math.abs(corr_diff) < 0.05
                                okq_compare := "TÆ°Æ¡ng quan á»•n Ä‘á»‹nh (ALL â‰ˆ OKQ)"
                            else if corr_diff > 0.1
                                okq_compare := "LOWQ lÃ m Yáº¾U tÆ°Æ¡ng quan â†’ Tin OKQ hÆ¡n"
                            else
                                okq_compare := "LOWQ lÃ m Máº NH tÆ°Æ¡ng quan â†’ Nghi ngá» overfit"
                        else
                            okq_compare := "ChÆ°a Ä‘á»§ dá»¯ liá»‡u Ä‘á»ƒ so sÃ¡nh"
                        f_cell(row_offset, 1, okq_compare, color.new(color.black,10), color.aqua, text.align_left)
                        table.merge_cells(t, 1, row_offset, 3, row_offset)
                    else
                        f_cell(row_offset, 0, "âš  KhÃ´ng Ä‘á»§ sample OKQ", color.new(color.orange,70), color.white, text.align_left)
                        table.merge_cells(t, 0, row_offset, 3, row_offset)
                else
                    // Not enough data
                    f_cell(row_offset, 0, "âš  Cáº§n thÃªm dá»¯ liá»‡u", color.new(color.orange,70), color.white, text.align_left)
                    table.merge_cells(t, 0, row_offset, 3, row_offset)
    else if panel == 5
        f_hdr(row_offset, "âš ï¸ Rá»¦I RO")
        row_offset += 1
        f_row(row_offset, "Rui ro", f_fmt(risk_pct,2)+"%", f_pctl_text(p_risk,true), p_risk, true, "Cao=nhiá»u Ã¡p lá»±c")
        f_row(row_offset+1, "Du bao rui ro", f_fmt(risk_forecast,2)+"%", f_pctl_text(p_risk_forecast,true), p_risk_forecast, true, "Dá»± bÃ¡o xu hÆ°á»›ng")
        f_row(row_offset+2, "Regime", f_bucket_label(current_bucket), "NA", na, true, "Cháº¿ Ä‘á»™ thá»‹ trÆ°á»ng")
        row_offset += 3
        string risk_interpretation = risk_pct > 70 ? "âš  Rá»¦I RO Ráº¤T CAO - PhÃ²ng thá»§" : risk_pct > 50 ? "âš  Rá»¦I RO CAO - Tháº­n trá»ng" : risk_pct < 30 ? "âœ… Rá»¦I RO THáº¤P - CÆ¡ há»™i" : "âž¡ TRUNG TÃNH"
        f_cell(row_offset, 0, "ÄÃ¡nh giÃ¡:", color.new(color.blue,20), color.white, text.align_left)
        color risk_interp_color = risk_pct > 70 ? color.new(color.red,60) : risk_pct > 50 ? color.new(color.orange,60) : risk_pct < 30 ? color.new(color.green,60) : color.new(color.black,10)
        f_cell(row_offset, 1, risk_interpretation, risk_interp_color, color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)
        row_offset += 1
        string forecast_guide = risk_forecast > risk_pct + 10 ? "âš  Cáº¢NH BÃO - Risk tÄƒng" : risk_forecast < risk_pct - 10 ? "âœ… TÃCH Cá»°C - Risk giáº£m" : "âž¡ á»”N Äá»ŠNH"
        f_cell(row_offset, 0, "Triá»ƒn vá»ng:", color.new(color.blue,20), color.white, text.align_left)
        color forecast_color = risk_forecast > risk_pct + 10 ? color.new(color.red,60) : risk_forecast < risk_pct - 10 ? color.new(color.green,60) : color.new(color.black,10)
        f_cell(row_offset, 1, forecast_guide, forecast_color, color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)

        row_offset += 2
        f_hdr(row_offset, "RISK COMPONENTS")
        row_offset += 1
        f_row(row_offset, "Láº¡m phÃ¡t (pháº§n)", f_fmt(S_infl,2), f_pctl_text(p_sinfl,true), p_sinfl, true, "ÄÃ³ng gÃ³p P1")
        f_row(row_offset+1, "LÃ£i suáº¥t (pháº§n)", f_fmt(S_pol,2), f_pctl_text(p_spol,true), p_spol, true, "ÄÃ³ng gÃ³p P2")
        f_row(row_offset+2, "TÄƒng trÆ°á»Ÿng (pháº§n)", f_fmt(S_grow,2), f_pctl_text(p_sgrow,true), p_sgrow, true, "Yáº¿u â†’ rá»§i ro")
        row_offset += 3
        f_row(row_offset, "Layer 1 (Funding)", f_fmt(layer1_score,2), f_pctl_text(p_layer1,true), p_layer1, true, "Thanh khoáº£n")
        f_row(row_offset+1, "Layer 2 (Cycle)", f_fmt(layer2_score,2), f_pctl_text(p_layer2,true), p_layer2, true, "Chu ká»³")
        f_row(row_offset+2, "Layer 3 (External)", f_fmt(layer3_score,2), f_pctl_text(p_layer3,true), p_layer3, true, "Quá»‘c táº¿")
        row_offset += 3
        f_cell(row_offset, 0, "Äá»™ tin:", color.new(color.blue,20), color.white, text.align_left)
        string eval_context = eval_vi + " | MAE=" + (na(mae24_m) ? "-" : f_fmt(mae24_m,2))
        color eval_bg = eval_vi == "Tin hieu: on dinh" ? color.new(color.green,60) : color.new(color.orange,60)
        f_cell(row_offset, 1, eval_context, eval_bg, color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)

        row_offset += 2
        row_offset := f_display_transition_matrix(row_offset)
    else if panel == 6
        f_row(row_offset, "M2 YoY", f_fmt(m2_yoy_m,2)+"%", f_pctl_text(p_m2,true), p_m2, false, "TÄƒng trÆ°á»Ÿng tÃ­n dá»¥ng")
        f_row(row_offset+1, "Credit (idx)", f_fmt(credit_idx,2), f_pctl_text(p_credit,true), p_credit, true, "Chá»‰ sá»‘ báº¥t thÆ°á»ng")
        row_offset += 2
        string credit_status = credit_high ? "âš  NÃ“NG - Ná»›i lá»ng quÃ¡ má»©c" : m2_yoy_m < 10 ? "âš  Láº NH - Tháº¯t cháº·t tÃ­n dá»¥ng" : "âœ… á»”N Äá»ŠNH"
        f_cell(row_offset, 0, "TÃ­n dá»¥ng:", color.new(color.blue,20), color.white, text.align_left)
        color credit_color = credit_high ? color.new(color.red,60) : m2_yoy_m < 10 ? color.new(color.orange,60) : color.new(color.green,60)
        f_cell(row_offset, 1, credit_status, credit_color, color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)
    else if panel == 7
        f_row(row_offset, "Val Distance", f_fmt(valuation_distance*100,2)+"%", "-", na, false, "So vá»›i MA200")
        f_row(row_offset+1, "Risk %", f_fmt(risk_pct,2)+"%", f_pctl_text(p_risk,true), p_risk, true, "Rá»§i ro vÄ© mÃ´")
        row_offset += 2
        string val_status = is_cheap ? "âœ… Ráºº - CÆ¡ há»™i tÃ­ch lÅ©y" : valuation_distance > 0.15 ? "âš  Äáº®T - Tháº­n trá»ng" : "âž¡ CÃ”NG Báº°NG"
        f_cell(row_offset, 0, "Äá»‹nh giÃ¡:", color.new(color.blue,20), color.white, text.align_left)
        color val_color = is_cheap ? color.new(color.green,60) : valuation_distance > 0.15 ? color.new(color.red,60) : color.new(color.black,10)
        f_cell(row_offset, 1, val_status, val_color, color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)
        row_offset += 1
        if bullish_divergence
            f_cell(row_offset, 0, "âš¡ PhÃ¢n ká»³:", color.new(color.green,60), color.white, text.align_left)
            f_cell(row_offset, 1, "TÃCH Cá»°C - CÆ¡ há»™i mua", color.new(color.green,50), color.white, text.align_left)
            table.merge_cells(t, 1, row_offset, 3, row_offset)
    else if panel == 9
        f_hdr(row_offset, "ðŸ› MARKET PERFORMANCE - Bucket " + f_bucket_label(current_bucket))
        row_offset += 1

        if use_regime_mapping and not na(current_bucket)
            // SUMMARY ROW - Current market context
            string market_context = ""
            if current_bucket == 0
                market_context := "ðŸ’š Rá»¦I RO Ráº¤T THáº¤P - Thá»‹ trÆ°á»ng thuáº­n lá»£i cho tÄƒng trÆ°á»Ÿng"
            else if current_bucket == 1
                market_context := "ðŸŸ¢ Rá»¦I RO THáº¤P - Váº«n tÃ­ch cá»±c, cÆ¡ há»™i tá»‘t"
            else if current_bucket == 2
                market_context := "ðŸŸ¡ Rá»¦I RO Vá»ªA - Tháº­n trá»ng, cÃ¢n báº±ng danh má»¥c"
            else if current_bucket == 3
                market_context := "ðŸŸ  Rá»¦I RO CAO - Giáº£m tá»· trá»ng, tÄƒng phÃ²ng thá»§"
            else
                market_context := "ðŸ”´ Rá»¦I RO Ráº¤T CAO - Báº£o toÃ n vá»‘n, trÃ¡nh mua má»›i"

            f_cell(row_offset, 0, "Bá»‘i cáº£nh:", color.new(color.navy,60), color.white, text.align_left)
            f_cell(row_offset, 1, market_context, f_bucket_bg(current_bucket), color.white, text.align_left)
            table.merge_cells(t, 1, row_offset, 3, row_offset)
            row_offset += 1

            // Horizon info
            f_cell(row_offset, 0, "Horizon:", color.new(color.gray,80), color.silver, text.align_left)
            f_cell(row_offset, 1, str.tostring(regime_return_horizon) + " bars forward", color.new(color.gray,80), color.white, text.align_left)
            table.merge_cells(t, 1, row_offset, 3, row_offset)
            row_offset += 1
            row_offset += 1

            // Headers with icons
            f_cell(row_offset, 0, "Index", color.new(color.navy,50), color.white, text.align_left)
            f_cell(row_offset, 1, "AvgR%", color.new(color.navy,50), color.white, text.align_center)
            f_cell(row_offset, 2, "Win%", color.new(color.navy,50), color.white, text.align_center)
            f_cell(row_offset, 3, "N", color.new(color.navy,50), color.white, text.align_center)
            row_offset += 1

            // Additional metrics row header
            row_offset += 1
            f_cell(row_offset, 0, "ðŸ“Š EXTENDED METRICS", color.new(color.purple,60), color.white, text.align_center)
            table.merge_cells(t, 0, row_offset, 3, row_offset)
            row_offset += 1
            f_cell(row_offset, 0, "Index", color.new(color.navy,50), color.white, text.align_left)
            f_cell(row_offset, 1, "R20%", color.new(color.navy,50), color.white, text.align_center)
            f_cell(row_offset, 2, "DD20%", color.new(color.navy,50), color.white, text.align_center)
            f_cell(row_offset, 3, "R60%", color.new(color.navy,50), color.white, text.align_center)
            row_offset += 1

            // Market indices data
            string[] mkt_names = array.from("VNINDEX", "VN30", "VN100", "MIDCAP", "SMALLCAP")
            int valid_count = 0

            for i = 0 to 4
                if not na(current_bucket) and current_bucket >= 0 and current_bucket <= 4
                    int idx = i * 5 + current_bucket
                    float sum_r = array.get(sumR_market, idx)
                    float cnt_r = array.get(cntR_market, idx)
                    float win_r = array.get(winR_market, idx)
                    if cnt_r >= min_N_display
                        valid_count += 1
                        string name = array.get(mkt_names, i)
                        float avg_r = f_avg(sum_r, cnt_r) * 100.0
                        float win_pct = f_winrate(win_r, cnt_r)

                        // Visual indicator + performance bar
                        string perf_icon = avg_r > 3 ? "ðŸŸ¢ " : avg_r > 0 ? "ðŸŸ¡ " : avg_r > -3 ? "ðŸŸ  " : "ðŸ”´ "
                        string win_icon = win_pct > 60 ? "â­" : win_pct > 50 ? "âœ“" : "âš "

                        // Color based on performance
                        color row_bg = avg_r > 5 ? color.new(color.green,75) :avg_r > 2 ? color.new(color.green,85) :   avg_r > -2 ? color.new(color.gray,85) :  avg_r > -5 ? color.new(color.orange,85) : color.new(color.red,80)

                        f_cell(row_offset, 0, perf_icon + name, row_bg, color.white, text.align_left)
                        f_cell(row_offset, 1, f_fmt(avg_r,2) + "%", row_bg, color.white, text.align_center)
                        f_cell(row_offset, 2, win_icon + " " + f_fmt(win_pct,1) + "%", row_bg, color.white, text.align_center)
                        f_cell(row_offset, 3, str.tostring(int(cnt_r)), row_bg, color.silver, text.align_center)
                        row_offset += 1

            // Display Extended Metrics (R20, DD20, R60)
            for i = 0 to 4
                if not na(current_bucket) and current_bucket >= 0 and current_bucket <= 4
                    int idx = i * 5 + current_bucket
                    float cnt_r20 = array.get(cntR20_market, idx)

                    if cnt_r20 >= min_N_display
                        string name = array.get(mkt_names, i)

                        // R20
                        float sum_r20 = array.get(sumR20_market, idx)
                        float avg_r20 = f_avg(sum_r20, cnt_r20) * 100.0

                        // DD20
                        float max_dd20 = array.get(maxDD20_market, idx)
                        float avg_dd20 = array.get(sumDD20_market, idx) / array.get(cntDD20_market, idx)

                        // R60
                        float sum_r60 = array.get(sumR60_market, idx)
                        float cnt_r60 = array.get(cntR60_market, idx)
                        float avg_r60 = cnt_r60 > 0 ? f_avg(sum_r60, cnt_r60) * 100.0 : na

                        // Colors
                        color r20_bg = avg_r20 > 5 ? color.new(color.green,75) : avg_r20 > 0 ? color.new(color.gray,85) : color.new(color.red,85)
                        color dd_bg = avg_dd20 < 0.05 ? color.new(color.green,75) : avg_dd20 < 0.10 ? color.new(color.orange,85) : color.new(color.red,85)

                        f_cell(row_offset, 0, name, color.new(color.black,10), color.white, text.align_left)
                        f_cell(row_offset, 1, not na(avg_r20) ? f_fmt(avg_r20,2)+"%" : "-", r20_bg, color.white, text.align_center)
                        f_cell(row_offset, 2, not na(avg_dd20) ? f_fmt(avg_dd20*100,2)+"%" : "-", dd_bg, color.white, text.align_center)
                        f_cell(row_offset, 3, not na(avg_r60) ? f_fmt(avg_r60,2)+"%" : "-", color.new(color.black,10), color.white, text.align_center)
                        row_offset += 1

            if valid_count == 0
                f_cell(row_offset, 0, "âš  ChÆ°a Ä‘á»§ dá»¯ liá»‡u (N < " + str.tostring(min_N_display) + ")", color.new(color.orange,70), color.white, text.align_left)
                table.merge_cells(t, 0, row_offset, 3, row_offset)
                row_offset += 1
            else
                // Summary statistics for market performance
                row_offset += 1
                // Find best and worst performer
                float best_perf = -999999
                float worst_perf = 999999
                string best_name = ""
                string worst_name = ""
                for i = 0 to 4
                    if not na(current_bucket) and current_bucket >= 0 and current_bucket <= 4
                        int idx = i * 5 + current_bucket
                        float sum_r = array.get(sumR_market, idx)
                        float cnt_r = array.get(cntR_market, idx)
                        if cnt_r >= min_N_display
                            float avg_r = f_avg(sum_r, cnt_r) * 100.0
                            if avg_r > best_perf
                                best_perf := avg_r
                                best_name := array.get(mkt_names, i)
                            if avg_r < worst_perf
                                worst_perf := avg_r
                                worst_name := array.get(mkt_names, i)

                if best_name != ""
                    f_cell(row_offset, 0, "â­ Tá»‘t nháº¥t:", color.new(color.green,75), color.white, text.align_left)
                    f_cell(row_offset, 1, best_name + " (+" + f_fmt(best_perf,2) + "%)", color.new(color.green,75), color.white, text.align_center)
                    f_cell(row_offset, 2, "âš  Yáº¿u nháº¥t:", color.new(color.red,75), color.white, text.align_left)
                    f_cell(row_offset, 3, worst_name + " (" + f_fmt(worst_perf,2) + "%)", color.new(color.red,75), color.white, text.align_center)
                    row_offset += 1

            // SECTOR ROTATION ANALYSIS
            row_offset += 1
            f_hdr(row_offset, "ðŸ”„ SECTOR ROTATION (Relative Return vs VNINDEX)")
            row_offset += 1

            // Explanation row
            f_cell(row_offset, 0, "RR% = Sector return - VNINDEX return", color.new(color.blue,85), color.aqua, text.align_left)
            table.merge_cells(t, 0, row_offset, 3, row_offset)
            row_offset += 1

            // Headers
            f_cell(row_offset, 0, "Sector", color.new(color.navy,50), color.white, text.align_left)
            f_cell(row_offset, 1, "RR%", color.new(color.navy,50), color.white, text.align_center)
            f_cell(row_offset, 2, "Win%", color.new(color.navy,50), color.white, text.align_center)
            f_cell(row_offset, 3, "Rank", color.new(color.navy,50), color.white, text.align_center)
            row_offset += 1

            // Collect sector data and rank
            string[] sec_names = array.from("VNFIN", "VNREAL", "VNCONS", "VNIND")
            float[] sec_rr = array.new_float(4, na)
            float[] sec_win = array.new_float(4, na)
            float[] sec_cnt = array.new_float(4, na)

            for i = 0 to 3
                if not na(current_bucket) and current_bucket >= 0 and current_bucket <= 4
                    int idx = i * 5 + current_bucket
                    float sum_rr = array.get(sumRR_sector, idx)
                    float cnt_rr = array.get(cntRR_sector, idx)
                    float win_rr = array.get(winRR_sector, idx)
                    if cnt_rr >= min_N_display
                        array.set(sec_rr, i, f_avg(sum_rr, cnt_rr) * 100.0)
                        array.set(sec_win, i, f_winrate(win_rr, cnt_rr))
                        array.set(sec_cnt, i, cnt_rr)

            // Display TOP 3 OUTPERFORMERS
            f_cell(row_offset, 0, "â­ TOP 3 OUTPERFORM:", color.new(color.green,70), color.white, text.align_left)
            table.merge_cells(t, 0, row_offset, 3, row_offset)
            row_offset += 1

            // Find top 3
            int top_count = 0
            for rank = 1 to 4
                if top_count >= 3
                    break

                int best_idx = -1
                float best_rr = -999999
                for i = 0 to 3
                    float rr_val = array.get(sec_rr, i)
                    if not na(rr_val) and rr_val > best_rr
                        bool already_used = false
                        // Check if already ranked (skip if i = 0 to avoid j = -1)
                        if i > 0
                            for j = 0 to i - 1
                                if array.get(sec_rr, j) == rr_val
                                    already_used := true
                        if not already_used or i == 0
                            best_rr := rr_val
                            best_idx := i

                if best_idx >= 0
                    string name = array.get(sec_names, best_idx)
                    float rr_val = array.get(sec_rr, best_idx)
                    float win_val = array.get(sec_win, best_idx)
                    float cnt_val = array.get(sec_cnt, best_idx)

                    string rank_icon = rank == 1 ? "ðŸ¥‡" : rank == 2 ? "ðŸ¥ˆ" : "ðŸ¥‰"
                    color row_bg = color.new(color.green, 80 + rank * 3)

                    f_cell(row_offset, 0, rank_icon + " " + name, row_bg, color.white, text.align_left)
                    f_cell(row_offset, 1, "+" + f_fmt(rr_val,2) + "%", row_bg, color.white, text.align_center)
                    f_cell(row_offset, 2, f_fmt(win_val,1) + "%", row_bg, color.white, text.align_center)
                    f_cell(row_offset, 3, "#" + str.tostring(rank), row_bg, color.yellow, text.align_center)
                    row_offset += 1
                    top_count += 1

                    // Mark as used
                    array.set(sec_rr, best_idx, -999999)

            // Display BOTTOM 3 UNDERPERFORMERS
            row_offset += 1
            f_cell(row_offset, 0, "âš  BOTTOM 3 UNDERPERFORM:", color.new(color.red,70), color.white, text.align_left)
            table.merge_cells(t, 0, row_offset, 3, row_offset)
            row_offset += 1

            // Reset sec_rr array
            for i = 0 to 3
                if not na(current_bucket) and current_bucket >= 0 and current_bucket <= 4
                    int idx = i * 5 + current_bucket
                    float sum_rr = array.get(sumRR_sector, idx)
                    float cnt_rr = array.get(cntRR_sector, idx)
                    if cnt_rr >= min_N_display
                        array.set(sec_rr, i, f_avg(sum_rr, cnt_rr) * 100.0)

            // Find bottom 3
            int bottom_count = 0
            for rank = 1 to 4
                if bottom_count >= 3
                    break

                int worst_idx = -1
                float worst_rr = 999999
                for i = 0 to 3
                    float rr_val = array.get(sec_rr, i)
                    if not na(rr_val) and rr_val < worst_rr and rr_val > -999998
                        worst_rr := rr_val
                        worst_idx := i

                if worst_idx >= 0
                    string name = array.get(sec_names, worst_idx)
                    float rr_val = array.get(sec_rr, worst_idx)
                    float win_val = array.get(sec_win, worst_idx)
                    float cnt_val = array.get(sec_cnt, worst_idx)

                    string rank_icon = rank == 1 ? "ðŸ”»" : rank == 2 ? "ðŸ”½" : "â¬‡"
                    color row_bg = color.new(color.red, 80 + rank * 3)

                    f_cell(row_offset, 0, rank_icon + " " + name, row_bg, color.white, text.align_left)
                    f_cell(row_offset, 1, f_fmt(rr_val,2) + "%", row_bg, color.white, text.align_center)
                    f_cell(row_offset, 2, f_fmt(win_val,1) + "%", row_bg, color.white, text.align_center)
                    f_cell(row_offset, 3, "#" + str.tostring(4 - rank + 1), row_bg, color.orange, text.align_center)
                    row_offset += 1
                    bottom_count += 1

                    // Mark as used
                    array.set(sec_rr, worst_idx, 999999)

            // SECTOR INSIGHTS based on bucket
            row_offset += 1
            string sector_insight = ""
            if current_bucket <= 1
                sector_insight := "ðŸ’¡ B0-B1: Æ¯u tiÃªn cyclical (VNFIN, VNIND), midcap/smallcap"
            else if current_bucket == 2
                sector_insight := "ðŸ’¡ B2: CÃ¢n báº±ng cyclical & defensive, quan sÃ¡t top sectors"
            else if current_bucket >= 3
                sector_insight := "ðŸ’¡ B3-B4: Æ¯u tiÃªn defensive, trÃ¡nh cyclical rá»§i ro cao"

            f_cell(row_offset, 0, "Sector Tip:", color.new(color.purple,80), color.white, text.align_left)
            f_cell(row_offset, 1, sector_insight, color.new(color.purple,80), color.white, text.align_left)
            table.merge_cells(t, 1, row_offset, 3, row_offset)
            row_offset += 1

            // INTERPRETATION GUIDE
            row_offset += 1
            f_cell(row_offset, 0, "ðŸ“– Bucket hiá»‡n táº¡i:", color.new(color.purple,75), color.white, text.align_left)
            f_cell(row_offset, 1, f_bucket_label(current_bucket), f_bucket_bg(current_bucket), color.white, text.align_center)
            table.merge_cells(t, 1, row_offset, 3, row_offset)
            row_offset += 1

            // Strategy recommendation based on bucket
            string bucket_strategy = ""
            if current_bucket == 0
                bucket_strategy := "âœ… B0: TÄƒng tá»· trá»ng equity, Æ°u tiÃªn midcap/smallcap"
            else if current_bucket == 1
                bucket_strategy := "âœ… B1: Duy trÃ¬ equity cao, chá»n top performers"
            else if current_bucket == 2
                bucket_strategy := "ðŸŸ¡ B2: CÃ¢n báº±ng, theo dÃµi chuyá»ƒn bucket"
            else if current_bucket == 3
                bucket_strategy := "âš  B3: Giáº£m dáº§n equity, tÄƒng defensive"
            else
                bucket_strategy := "ðŸ”´ B4: PhÃ²ng thá»§ tá»‘i Ä‘a, cash/gold/bonds"

            f_cell(row_offset, 0, "ðŸ’¡ Chiáº¿n lÆ°á»£c:", color.new(color.blue,75), color.white, text.align_left)
            f_cell(row_offset, 1, bucket_strategy, color.new(color.black,10), color.white, text.align_left)
            table.merge_cells(t, 1, row_offset, 3, row_offset)
            row_offset += 1

            // Market timing hint
            string timing_hint = ""
            if risk_forecast < risk_pct - 10
                timing_hint := "ðŸ“ˆ Risk giáº£m dáº§n â†’ CÆ¡ há»™i tÃ­ch lÅ©y"
            else if risk_forecast > risk_pct + 10
                timing_hint := "ðŸ“‰ Risk tÄƒng dáº§n â†’ Chá» Ä‘iá»u chá»‰nh"
            else
                timing_hint := "âž¡ Risk á»•n Ä‘á»‹nh â†’ Duy trÃ¬ vá»‹ tháº¿"

            f_cell(row_offset, 0, "Timing:", color.new(color.blue,75), color.white, text.align_left)
            f_cell(row_offset, 1, timing_hint, color.new(color.black,10), color.white, text.align_left)
            table.merge_cells(t, 1, row_offset, 3, row_offset)
        else
            // Regime mapping disabled OR current_bucket is invalid
            string error_msg = ""
            if not use_regime_mapping
                error_msg := "âš  Regime Mapping bá»‹ táº¯t"
            else if na(current_bucket)
                error_msg := "âš  Bucket chÆ°a sáºµn sÃ ng (cáº§n dá»¯ liá»‡u lá»‹ch sá»­)"
            else
                error_msg := "âš  Dá»¯ liá»‡u chÆ°a Ä‘á»§"

            f_cell(row_offset, 0, error_msg, color.new(color.orange,70), color.white, text.align_left)
            table.merge_cells(t, 0, row_offset, 3, row_offset)
            row_offset += 1

            string help_msg = ""
            if not use_regime_mapping
                help_msg := "ðŸ‘‰ Báº­t 'Bat Regime Mapping' Ä‘á»ƒ xem Market & Sector analysis"
            else
                help_msg := "ðŸ‘‰ Chá» tÃ­ch lÅ©y Ä‘á»§ dá»¯ liá»‡u lá»‹ch sá»­ (cáº§n Ã­t nháº¥t " + str.tostring(regime_return_horizon) + " bars)"

            f_cell(row_offset, 0, help_msg, color.new(color.gray,85), color.silver, text.align_left)
            table.merge_cells(t, 0, row_offset, 3, row_offset)
        f_hdr(row_offset, "ðŸ“ˆ YIELD CURVE LAB (L-S-C + Quality)")
        row_offset += 1

    else if panel == 10
        f_hdr(row_offset, "US TREASURY YIELD CURVE ANALYSIS")
        row_offset += 1

        // LSC FACTORS - Use helper function
        row_offset += 1
        row_offset := f_yc_display_lsc(t, row_offset, us_level, us_yc_slope, us_curve, us_level_change, us_slope_ma, us_slope_z)

        // REGIME CLASSIFICATION - Use helper function
        row_offset += 1
        row_offset := f_yc_display_regime(t, row_offset, us_regime, us_level_regime, us_policy_stance)

        // QUALITY METRICS - Use helper function
        row_offset += 1
        row_offset := f_yc_display_quality(t, row_offset, us_quality_score, us_10y_vol, us_02y_vol)
        float vn_us_spread = not na(vn10y_m) and not na(us10y_m) ? vn10y_m - us10y_m : na


        // INTERPRETATION
        row_offset += 1
        f_cell(row_offset, 0, "INTERPRETATION", color.new(color.navy,50), color.white, text.align_center)
        table.merge_cells(t, 0, row_offset, 3, row_offset)
        row_offset += 1

        string us_interpretation = f_yc_regime_interp(us_regime, us_level_regime, us_policy_stance)

        f_cell(row_offset, 0, "US Status:", color.new(color.purple,75), color.white, text.align_left)
        f_cell(row_offset, 1, us_interpretation, color.new(color.black,10), color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)
        row_offset += 1

        string vn_impact = f_vn_impact_from_us(vn_us_spread, fed_gap)

        f_cell(row_offset, 0, "VN Impact:", color.new(color.purple,75), color.white, text.align_left)
        f_cell(row_offset, 1, vn_impact, color.new(color.black,10), color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)
        row_offset += 1

        // TRADING IMPLICATIONS
        row_offset += 1
        f_cell(row_offset, 0, "TRADING IMPLICATIONS", color.new(color.navy,50), color.white, text.align_center)
        table.merge_cells(t, 0, row_offset, 3, row_offset)
        row_offset += 1

        string trading_view = f_yc_trading_view(us_regime, us_level_regime, us_policy_stance)

        f_cell(row_offset, 0, "Strategy:", color.new(color.blue,75), color.white, text.align_left)
        f_cell(row_offset, 1, trading_view, color.new(color.black,10), color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)
        row_offset += 1

        string us_timing = f_yc_timing(us_slope_z)

        f_cell(row_offset, 0, "Timing:", color.new(color.blue,75), color.white, text.align_left)
        f_cell(row_offset, 1, us_timing, color.new(color.black,10), color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)
        row_offset += 1

        // YIELD CURVE LAB (VN) - Use helper function
        row_offset := f_yc_display_vn_lab(t, row_offset, yc_level, yc_slope, yc_curve, yc_regime_code, yc_quality, yc_quality_label, yc_distortion, yc_stress_raw, yc_stress_adj)

        row_offset += 1
        f_cell(row_offset, 0, "Giáº£i thÃ­ch:", color.new(color.blue,20), color.white, text.align_left)
        string yc_explain = yc_quality_label == "LOWQ" ? "âš  Quality tháº¥p - Dá»¯ liá»‡u mÃ©o/nhiá»…u" :
                           yc_regime_code == "YC4" ? "ðŸ”´ YC4: Level cao + flat/inverted" :
                           yc_regime_code == "YC1" ? "ðŸŸ¢ YC1: Easing mature" :
                           "ðŸŸ¡ Trung tÃ­nh - Theo dÃµi"
        f_cell(row_offset, 1, yc_explain, color.new(color.black,10), color.white, text.align_left)
        table.merge_cells(t, 1, row_offset, 3, row_offset)

    row_offset += 8
    string rec_short = ""
    string rec_mid = ""
    string rec_long = ""
    if bullish_divergence and is_cheap
        rec_short := "â­ GOM HÃ€NG: PhÃ¢n ká»³ tÃ­ch cá»±c + GiÃ¡ ráº»"
        rec_mid := "TÃ­ch lÅ©y dáº§n, DCA theo nhá»‹p Ä‘iá»u chá»‰nh"
        rec_long := "Náº¯m giá»¯ dÃ i háº¡n, chá» vÄ© mÃ´ cáº£i thiá»‡n"
    else if current_bucket >= 3 and not is_cheap
        rec_short := "PHÃ’NG THá»¦: Giáº£m tá»· trá»ng equity"
        rec_mid := "Chá» Ä‘iá»u chá»‰nh máº¡nh hoáº·c vÄ© mÃ´ cáº£i thiá»‡n"
        rec_long := "Hedge FX + VÃ ng"
    else if macro_improving
        rec_short := "TÄ‚NG Dáº¦N: VÄ© mÃ´ Ä‘ang cáº£i thiá»‡n"
        rec_mid := "Mua dip chá»n lá»c"
        rec_long := "DÃ i háº¡n tÃ­ch cá»±c"
    else
        rec_short := "CÃ‚N Báº°NG: Giá»¯ vá»‹ tháº¿ hiá»‡n táº¡i"
        rec_mid := "Theo dÃµi Risk Forecast"
        rec_long := "TÃ¡i cÃ¢n báº±ng Ä‘á»‹nh ká»³"

    f_cell(row_offset+1,0,"Ngáº¯n háº¡n",color.new(color.blue,20),color.white,text.align_left)
    f_cell(row_offset+1,1,rec_short,color.new(color.black,10),color.white,text.align_left)
    table.merge_cells(t, 1, row_offset+1, 3, row_offset+1)

    f_cell(row_offset+2,0,"Trung háº¡n",color.new(color.blue,20),color.white,text.align_left)
    f_cell(row_offset+2,1,rec_mid,color.new(color.black,10),color.white,text.align_left)
    table.merge_cells(t, 1, row_offset+2, 3, row_offset+2)

    f_cell(row_offset+3,0,"DÃ i háº¡n",color.new(color.blue,20),color.white,text.align_left)
    f_cell(row_offset+3,1,rec_long,color.new(color.black,10),color.white,text.align_left)
    table.merge_cells(t, 1, row_offset+3, 3, row_offset+3)
