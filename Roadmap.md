# Stage 1: Computer Science Fundamentals

- OOP & Design pattern
- DSA * Algorithm
- TDD BDD


**Resource**:

- The Pragmatic Programmer
- Test Driven Development - Kent Beck
- Design pattern - GoF
- Clean code
- CLean architecutre 

# Stage2: System Knowledge

- Operating systems internal
- Process / thread lifecycle
- Memory management, caching, paging, virtual memory
- Networking protocol
- Api design
- Api security best practice
- TCP/ IP, UDP, HTTP, HTTPS, Rest, gRPC,GrapQL

**Resource**:

- Operating Systems: Three easy pieces
- Operating System Concepts
- Computer Networking: A top-down approach
- Unix network programming
- OWASP API security project
- TCP/IP illustrated by Richard Steven
- Operating system and you (Cousera)

# Stage3: System Design and Architecture

- Designing data intensive applications
- The site reliability workbook
- Building microservice
- System design primer
- Fundamentals of software architecture
- Architecture decision records (ADR) and document template 

# Stage4: Performance and Optimization

- Profiling tools to identify CPU, Memory, I/O bottenecks
- Tune concurrency, optimize queries, use cache

**Resource**:
- High performance browser Networking
- Concurrency in practice

# Stage5: Security

- OWASP top 10
- The web application hacker handbook
- Cryptography coursera

# Stage6: Interview

- System design interview - alex xu
- Cracking the coding interview
- Behavioral interview (STAR, CAR)
- Decode and Conquer
- Staff engineer interview guides (Randy shoup, will larson)


# Leetcode

| #   | Pattern Name                               | Description                                                                                        |
| --- | ------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| 1   | **Sliding Window**                         | Efficiently handle problems involving contiguous subarrays, substrings, or sequences.              |
| 2   | **Two Pointers**                           | Use two pointers moving at different speeds or from both ends to reduce time complexity.           |
| 3   | **Fast & Slow Pointers (Cycle Detection)** | Detect cycles in linked lists or sequences using two pointers moving at different speeds.          |
| 4   | **Merge Intervals**                        | Solve problems that involve overlapping intervals, calendars, and ranges.                          |
| 5   | **Binary Search**                          | Search for elements or conditions in sorted arrays or monotonic functions in O(log n).             |
| 6   | **Depth-First Search (DFS)**               | Explore all paths deeply, often using recursion or stacks; common in trees and graphs.             |
| 7   | **Breadth-First Search (BFS)**             | Explore all nodes at the same depth level first, typically using queues.                           |
| 8   | **Backtracking**                           | Use recursion and undo steps to explore all possibilities, especially in puzzles and combinations. |
| 9   | **Dynamic Programming (DP)**               | Solve problems by storing results of subproblems to avoid redundant work.                          |
| 10  | **Topological Sort**                       | Linear ordering of vertices in a Directed Acyclic Graph (DAG), often used in scheduling problems.  |
| 11  | **Greedy**                                 | Make locally optimal choices at each step to achieve a globally optimal solution.                  |
| 12  | **Trie (Prefix Tree)**                     | Specialized tree structure for efficient string prefix searching.                                  |
| 13  | **Heap / Priority Queue**                  | Efficient for problems involving order statistics like k-largest or k-smallest elements.           |
| 14  | **Union Find (Disjoint Set)**              | Solve dynamic connectivity problems, used in Kruskalâ€™s algorithm and cycle detection.              |
| 15  | **Graph (Adjacency List / Matrix)**        | Core structure for solving traversal, path, or component problems.                                 |
| 16  | **Bit Manipulation**                       | Use bitwise operators for optimized integer computations, especially for subsets or flags.         |
| 17  | **Top K Elements**                         | Use heaps or frequency maps to find the top-k frequent elements or highest values.                 |
| 18  | **Knapsack (0/1 DP)**                      | Solve optimization problems where you choose to include or exclude elements under constraints.     |
| 19  | **Monotonic Stack / Queue**                | Stack or queue that maintains increasing/decreasing order for range-based problems.                |
| 20  | **Prefix Sum**                             | Precompute running totals to answer range sum queries efficiently.                                 |
| 21  | **Flood Fill / Matrix DFS-BFS**            | Explore connected regions in grids, e.g., for islands or coloring problems.                        |
| 22  | **In-Place Modification**                  | Modify arrays/structures without using extra space, often with pointer manipulation.               |
| 23  | **Recursion & Divide and Conquer**         | Break problem into smaller subproblems; used in merge sort, quicksort, etc.                        |
| 24  | **Mathematical / Combinatorics**           | Problems based on permutations, combinations, or number theory logic.                              |
| 25  | **Linked List Manipulation**               | Specific techniques for reversing, merging, or splitting linked lists.                             |
| 26  | **Simulation**                             | Step-by-step implementation of a system's behavior or rules.                                       |
| 27  | **State Space Search** *(Unique)*          | Explore combinations of states, especially for constraint-based puzzles like N-Queens, Sudoku.     |
