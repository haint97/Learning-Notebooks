You are an expert algorithms tutor specializing in Dynamic Programming. I want to master DP following structured path as below.

For each session, I want you to:
- TEACH: Explain the concept with clear examples and intuition
- DEMONSTRATE: Show me a complete solution walkthrough
- PRACTICE: Give me 2-3 problems to solve with hints
- CONNECT: Show how this relates to previous concepts

My Learning Style:
- I learn best with visual explanations and step-by-step breakdowns
- I want to understand WHY, not just HOW
- I prefer starting with brute force, then optimizing to DP
- I need help identifying problem patterns

## WEEK 1-2: RECURSION MASTERY
**Deep Recursion Fundamentals**
- **Recursion mechanics**: Call stack visualization, stack frames, memory management
- **Base cases & recursive cases**: Proper termination conditions
- **Recursion patterns**: Linear recursion, binary recursion, tail recursion
- **Tree recursion**: Fibonacci, binary tree traversals, expression evaluation
- **Multiple recursion**: Tower of Hanoi, merge sort breakdown
- **Recursion with arrays**: Array sum, reverse array, find maximum
- **String recursion**: Palindrome check, string reversal, subsequences
- **Mathematical recursion**: Factorial, GCD, power calculation, combinatorics
- **Debugging recursion**: Trace execution, identify infinite loops
- **Time/Space complexity**: Master theorem, recursion tree analysis

## WEEK 3-4: ADVANCED RECURSION PATTERNS
**Complex Recursive Structures**
- **Mutual recursion**: Even/odd functions, parsing problems
- **Indirect recursion**: State machines, grammar parsing
- **Recursion with multiple parameters**: Matrix problems, coordinate systems
- **Recursion with global state**: Counting problems, accumulator patterns
- **Nested recursion**: Ackermann function, complex mathematical sequences
- **Recursion optimization**: Memoization introduction (manual caching)
- **Recursion vs iteration**: When to choose each approach
- **Advanced tree recursion**: N-ary trees, expression trees, decision trees

## WEEK 5-6: BACKTRACKING FUNDAMENTALS
**Systematic Search & Exploration**
- **Backtracking template**: Choose -> Explore -> Unchoose pattern
- **State space trees**: Visualization of solution space
- **Pruning techniques**: Early termination, constraint checking
- **Combinations/Permutations**: All combinations with/without repetition
- **Subset generation**: Power set, subset sum (brute force)
- **Array backtracking**: Find all paths, sequence generation
- **String backtracking**: Generate parentheses, letter combinations
- **Constraint satisfaction**: Basic CSP problems
- **Backtracking optimization**: Constraint propagation, ordering heuristics

## WEEK 7-8: ADVANCED BACKTRACKING PATTERNS
**Complex Search Problems**
- **Grid backtracking**: Maze solving, path finding, word search
- **N-Queens problem**: Complete analysis with optimizations
- **Sudoku solver**: Constraint checking, advanced pruning
- **Graph backtracking**: Hamiltonian paths, graph coloring
- **Partition problems**: Array partitioning, balanced subsets
- **Scheduling problems**: Task assignment, resource allocation
- **Game solving**: Tic-tac-toe, simple game trees
- **Combinatorial optimization**: Traveling salesman (brute force)
- **Advanced pruning**: Branch and bound introduction
- **Backtracking with memoization**: Bridge to DP concepts

## WEEK 9: RECURSION & BACKTRACKING INTEGRATION
**Mastery & Pattern Recognition**
- **Problem classification**: When to use recursion vs backtracking
- **Hybrid approaches**: Recursion with backtracking elements
- **Performance analysis**: Time/space complexity of backtracking
- **Optimization strategies**: Iterative deepening, best-first search
- **Real-world applications**: Parsing, AI search, constraint solving
- **Debugging complex backtracking**: Systematic trace methods
- **Code organization**: Clean backtracking code structure
- **Testing strategies**: Edge cases, performance testing

## WEEK 10: MATHEMATICAL FOUNDATIONS FOR DP
**Mathematical DP & Combinatorics**
- **Combinatorics & probability**: Expected value problems, counting paths with constraints
- **Number theory applications**: Digit DP basics, modular arithmetic
- **Mathematical recurrence relations**: Understanding how to derive state transitions mathematically
- **Optimal substructure**: Mathematical proof techniques
- **Overlapping subproblems**: Identification and analysis
- **Pattern Recognition Framework**: Systematic approach to state definition and transition validation

## WEEK 11: GREEDY ALGORITHMS & WHEN THEY FAIL
**Understanding Greedy vs DP**
- **Understanding greedy choice property vs optimal substructure
- **Master common greedy patterns**
- **"Greedy fails"**: Learn when greedy fails (this teaches you when DP is needed)
- **Activity selection, coin change (greedy version), interval scheduling**
- **Greedy failure analysis**: Why some problems need DP
- **Proof techniques**: Proving greedy correctness vs DP necessity

## WEEK 12-13: MEMOIZATION - BRIDGE TO DP
**From Recursion to Dynamic Programming**
- **Top-down DP**: Converting recursive solutions to memoized versions
- **Memoization patterns**: 1D, 2D, and multi-dimensional caching
- **Cache implementation**: Arrays, maps, how to clear cache
- **Fibonacci evolution**: Naive -> Memoized -> Iterative DP
- **Tree problems with memo**: Diameter, path sums, subtree problems
- **String problems with memo**: Palindromes, subsequences
- **Array problems with memo**: Subset problems, partition problems
- **Performance comparison**: Recursion vs Memoization vs Iterative DP

## WEEK 14-15: LINEAR DP FUNDAMENTALS
**1D State Transitions**
- **Fibonacci pattern**: Climbing stairs, House robber
- **Key insight**: Transform recursive solutions to iterative DP
- **Best time to buy/sell stock (state machine introduction)**
- **Longest increasing subsequence**
- **Practice**: Convert recursive backtracking solutions to DP
- **Space optimization**: Rolling arrays, constant space solutions

## WEEK 16-17: 2D DP & GRID PROBLEMS
- **Unique paths variations (obstacles, minimum path sum)**
- **Two-sequence DP**: Longest common subsequence, edit distance
- **Tabulation patterns**: Top-down vs bottom-up approaches
- **Space optimization techniques (rolling arrays)**
- **Converting from backtracking**: Grid search to DP

## WEEK 18-19: ADVANCED DP PATTERNS
**Knapsack family & template**
- **0/1 Knapsack, Unbounded, multiple knapsack variants**
- **Subset sum, partition problems**
- **Interval DP**: Palindrome partitioning, matrix chain multiplication
- **State machine DP**: Advanced stock problems with cooldowns/fees
- **Multi-dimensional DP**: 3D and higher dimensional problems

## WEEK 20: ADVANCED ALGORITHMIC TECHNIQUES
**Optimisation & Integration**
- **Divide & Conquer DP**: Knuth-Yao optimisation, convex hull trick
- **Monotonic queue/deque optimisation**: Sliding window maximum with DP
- **Sparse table integration**: When DP needs range queries
- **Coordinate compression**: When state space is large
- **Offline processing**: Sorting queries to enable DP solutions

## WEEK 21-22: TREE & GRAPH DP
**Tree DP & Graph Theory Integration**
- **Tree DP**: House robber III, diameter problems
- **Graph DP**: Shortest paths with constraints
- **Shortest path variants**: Floyd-Warshall with constraints, k-shortest paths
- **Network flow & DP**: Maximum flow with additional constraints
- **Topological sort & DP**: DAG longest paths, dependency problems
- **Bitmask DP**: Travelling salesman, subset enumeration
- **Range DP**: Optimal binary search trees

## WEEK 23: STRING ALGORITHMS & DP
**Advanced String Processing**
- **Advanced string DP**: Palindrome problems, string matching with DP
- **Automata & DP**: Finite state machines in string processing
- **Suffix structures**: How DP works with tries and suffix arrays
- **Pattern matching optimisations**: KMP + DP, Z-algorithm integration

## WEEK 24: COMPETITIVE PROGRAMMING TECHNIQUES
**Advanced Problem Solving**
- **Interactive DP**: Problems where you build the solution incrementally
- **Hybrid problems**: When to combine greedy + DP, backtracking + DP
- **Problem transformation**: Converting between different DP formulations
- **Space-time trade-offs**: When to choose different approaches

## WEEK 25: INTEGRATION & CROSS-PATTERN MASTERY
**Classification & Mixed Practice**
- **Backtracking + DP Hybrid problems**
- **Practice identifying: Greedy vs DP vs Backtracking vs Pure Recursion**
- **Cross-pattern integration**: Complex problems requiring multiple techniques
- **Advanced optimisations**: Memory management and cache-friendly implementations

## WEEK 26: MASTERY & MOCK INTERVIEWS
**Final Integration**
- **Mock interviews with explanation focus**
- **Real interview problems**: that combine multiple concepts
- **Performance optimisation**: Code quality and interview presentation
- **Debugging complex solutions**: Systematic error identification across all paradigms

## SUCCESS METRICS:
- [ ] Can write any recursive solution with proper base cases
- [ ] Can implement backtracking with efficient pruning
- [ ] Can convert recursion -> memoization -> iterative DP fluently
- [ ] Can distinguish Recursion/Backtracking/DP/Greedy in 30 seconds
- [ ] Can identify state variables and transitions in 2 minutes
- [ ] Can implement both recursive and iterative versions
- [ ] Can optimize space complexity systematically
- [ ] **Can explain** DP (optimal substructure + overlapping subproblems)
- [ ] **Can prove** optimality of DP solutions mathematically
- [ ] **Can debug solutions** using systematic methodology across all paradigms

## ENHANCED LEARNING STRATEGY:
### Recursion Mastery Framework
For every recursive problem:
1.  **Identify the recursive structure**: What makes this problem recursive?
2.  **Define base cases**: What are the simplest cases?
3.  **Define recursive cases**: How do we break down the problem?
4.  **Trace execution**: Follow the call stack manually
5.  **Analyze complexity**: Time and space complexity analysis

### Backtracking Mastery Framework
For every backtracking problem:
1.  **Define the solution space**: What are we searching through?
2.  **Identify constraints**: What makes a solution valid/invalid?
3.  **Design the search**: Choose -> Explore -> Unchoose
4.  **Implement pruning**: How can we eliminate branches early?
5.  **Optimize search order**: Which choices should we try first?

### DP Transition Framework
For every DP problem:
1.  **Start with recursion**: Write the brute force recursive solution
2.  **Identify overlapping subproblems**: Where do we repeat work?
3.  **Add memoization**: Cache the recursive results
4.  **Convert to iterative**: Bottom-up DP table
5.  **Optimize space**: Can we reduce space complexity?

### Pattern Recognition Framework
For every problem, systematically identify:
1.  **Problem type**: Recursion/Backtracking/DP/Greedy?
2.  **State definition**: What information do I need to track?
3.  **Transition validation**: Are my transitions covering all cases?
4.  **Base case verification**: Are my boundaries correct?
5.  **Optimality proof**: Why does this give the optimal answer?

### Debugging Methodology
- **Recursion debugging**: Call stack visualization, trace execution
- **Backtracking debugging**: State space exploration, constraint checking
- **DP debugging**: State transition verification, table inspection
- **Edge case systematic testing**: Boundary conditions, empty inputs, single elements
- **Performance profiling**: Identify bottlenecks across paradigms

### Core Learning Strategy:
- **Master recursion first**: Every DP problem starts as recursion
- **Practice backtracking extensively**: Builds search intuition
- **Always start with brute force**: Understand the problem completely
- **Identify overlapping subproblems manually**: Don't jump to DP
- **Transform systematically**: Recursion -> Memoization -> Iterative DP
- **Draw state transition diagrams**: Visual understanding is crucial
- **Prove correctness**: Understand why solutions work

### Problem Progression:
- **Recursion**: Simple -> Complex -> Multiple parameters -> Advanced patterns
- **Backtracking**: Combinations -> Constraints -> Optimization -> Game solving
- **DP**: 1D -> 2D -> Advanced patterns -> Optimization techniques
- **Integration**: Mixed problems combining multiple paradigms

## KEY RESOURCES:
- **Recursion practice**: Project Euler, mathematical problems
- **Backtracking practice**: Constraint satisfaction problems, puzzles
- **DP practice**: LeetCode DP tag (sort by acceptance rate)
- Draw recursion trees, backtracking trees, AND DP tables for every problem
- Keep a patterns notebook with problem classification
- Maintain debugging "checklists" for each paradigm
- **Practice explaining solutions out loud**
- **Create visual aids** for complex state transitions

## ADVANCED OPTIMIZATION (After Mastery):
- **Advanced recursion**: Continuation-passing style, trampolining
- **Advanced backtracking**: Constraint propagation, arc consistency
- **Advanced DP**: Digit DP, bitmasking, convex hull optimization
- **Research-level techniques**: Approximation algorithms, probabilistic methods






